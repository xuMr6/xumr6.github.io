<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XuMr</title>
  
  
  <link href="https://github.com/xuMr6/xumr6.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xuMr6/xumr6.github.io.git/"/>
  <updated>2020-09-13T13:07:32.000Z</updated>
  <id>https://github.com/xuMr6/xumr6.github.io.git/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python基础知识点大全</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/09/06/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/09/06/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</id>
    <published>2020-09-05T16:01:17.000Z</published>
    <updated>2020-09-13T13:07:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python知识点"><a href="#Python知识点" class="headerlink" title="Python知识点"></a>Python知识点</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><ol><li>进程是资源分配最小单位</li><li><strong>一个运行起来的程序就是一个进程</strong><br>什么是程序（程序是我们存储在硬盘里的代码、文件）<br>当我们双击图标，打开程序的时候，实际上就是通过I/O操作（读写）内存条里面<br>内存条就是我们所指的资源</li><li>进程之间内存独立，不能相互访问</li></ol><p><strong>进程定义拓展回答内容</strong>：</p><ol><li>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，这种执行的程序就称之为进程</li><li>程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念</li><li>在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。</li><li>进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</li><li>进程之间有自己独立的内存，各进程之间不能相互访问</li><li>创建一个新线程很简单，创建新进程需要对父进程进行复制</li></ol><h4 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h4><ol><li>程序只是一个普通文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体</li><li>而进程是程序运行在数据集上的动态过程，进程是一个动态实体，它应创建而产生，应调度执行因等待资源或事件而被处于等待状态，因完成任务而被撤消</li><li>进程是系统进行资源分配和调度的一个独立单位</li><li>一个程序对应多个进程，一个进程为多个程序服务（两者之间是多对多的关系）</li><li>一个程序执行在不同的数据集上就成为不同的进程，进程可以控制 块 来唯一标识每个程序</li></ol><p><strong>多道编程概念</strong>:</p><ul><li>多道编程： 在计算机内存中同时存放几道相互独立的程序，他们共享系统资源，相互穿插运行</li><li>单道编程： 计算机内存中只允许一个的程序运行</li></ul><p><code>进程具有独立的内存空间，所以没有办法相互通信</code><br><strong>进程通信</strong>:</p><p>python提供了多种进程通信的方式，主要<strong>Queue</strong>和<strong>Pipe</strong>这两种方式，<strong>Queue</strong>用 于多个进程间实现通信，<strong>Pipe</strong>是两个进程的通信。</p><ul><li>Queue有两个方法：<br>\1. Put方法：以插入数据到队列中<br>\2. Get方法：从队列读取并且删除一个元素</li><li>Pipe常用于两个进程，两个进程分别位于管道的两端<br>Pipe方法返回（conn1,conn2）代表一个管道的两个端，Pipe方法有duplex参数，默认为True，即全双工模式，若为FALSE，conn1只负责接收信息，conn2负责发送，</li><li>managers</li><li>RabbitMQ、redis等</li></ul><p><strong>进程间互相访问数据的四种方法</strong>:<br><code>注：不同进程间内存是不共享的，所以互相之间不能访问对方数据</code></p><ol><li>利用Queues实现父进程到子进程（或子进程间）的数据传递</li><li>使用管道pipe实现两个进程间数据传递</li><li>Managers实现很多进程间数据共享</li><li>借助redis中间件进行数据共享</li></ol><p><strong>进程池</strong>:<br>为什么需要进程池?</p><ul><li>一次性开启指定数量的进程</li><li>如果有十个进程，有一百个任务，一次可以处理多少个（一次性只能处理十个）</li><li>防止进程开启数量过多导致服务器压力过大</li><li>开进程池是为了效率,进程直接的切换是属于IO调度，每个进程的内存空间都有自己的寄存器，堆栈和文件。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  multiprocessing <span class="keyword">import</span> Process,Pool</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">i</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&quot;in the process&quot;</span>,os.getpid()) <span class="comment">#打印子进程的pid</span></span><br><span class="line"><span class="keyword">return</span> i+<span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">arg</span>):</span></span><br><span class="line">print(<span class="string">&#x27;--&gt;exec done:&#x27;</span>,arg,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = Pool(<span class="number">3</span>)                      <span class="comment">#进程池最多允许5个进程放入进程池</span></span><br><span class="line">    print(<span class="string">&quot;主进程pid：&quot;</span>,os.getpid())     <span class="comment">#打印父进程的pid</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">       <span class="comment">#用法1 callback作用是指定只有当Foo运行结束后就执行callback调用的函数,父进程调用的callback函数</span></span><br><span class="line">        pool.apply_async(func=foo, args=(i,),callback=call)</span><br><span class="line">        <span class="comment">#用法2 串行 启动进程不在用Process而是直接用pool.apply()</span></span><br><span class="line">        <span class="comment"># pool.apply(func=foo, args=(i,))</span></span><br><span class="line">    print(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    pool.close()    <span class="comment">#关闭pool</span></span><br><span class="line">    pool.join()     <span class="comment">#进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>进程池优点</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不仅仅减少了IO而且还减少了内存。</span><br><span class="line">下面的例子便可以区分 其他语言的进程池还可以根据服务器的压力来增减，有着上限和下限。</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><strong>建议：超过五个进程就用进程池</strong></p><p><strong>有了进程为什么还要线程？</strong></p><ol><li>进程优点：<br>提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率</li><li>进程的两个重要缺点<br>a. 第一点：进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。<br>b. 第二点：进程在执行的过程中如果阻塞，即使进程中有些工作不依赖于输入的数据，也将无法执行（例如等待输入，整个进程就会挂起）。<br>c. 例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、又能监听其它人给你发的消息<br>d. 你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀<br>e. 即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀</li></ol><hr><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><strong>线程的定义</strong>:</p><ol><li>线程是系统调度的最小单位</li><li>同进程下线程资源共享</li><li>进程无法自己执行，只有通过线程操作CPU，内存</li><li>为了保证数据安全，必须使用线程锁</li></ol><p><strong>线程定义拓展回答内容</strong>:</p><ol><li>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位</li><li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</li><li>无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行</li><li>进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合</li><li>所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同</li><li>同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程</li><li>两个进程想通信，必须要通过一个中间代理</li><li>对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存</li></ol><p><strong>进程和线程的区别</strong>:</p><ol><li>进程包含线程</li><li>线程共享内存空间</li><li>进程内存是独立的（不可互相访问）</li><li>进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程）</li><li>在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现</li><li>创建新线程很简单，创建新进程需要对其父进程进行克隆。</li><li>一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。</li><li>父进程可以修改不影响子进程，但不能修改。</li><li>线程可以帮助应用程序同时做几件事</li></ol><p><strong>for循环同时启动多个线程</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">num</span>):</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p><strong>t.join()： 实现所有线程都执行结束后再执行主线程</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">num</span>):</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">t_objs = []    <span class="comment">#将进程实例对象存储在这个列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">    t_objs.append(t)</span><br><span class="line">print(threading.active_count())    <span class="comment">#打印当前活跃进程数量</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> t_objs: <span class="comment">#利用for循环等待上面50个进程全部结束</span></span><br><span class="line">    t.join()     <span class="comment">#阻塞某个程序</span></span><br><span class="line">print(threading.current_thread())    <span class="comment">#打印执行这个命令进程</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;----------------all threads has finished.....&quot;</span>)</span><br><span class="line">print(threading.active_count())</span><br><span class="line">print(<span class="string">&#x27;cost time:&#x27;</span>,time.time() - start_time)</span><br></pre></td></tr></table></figure><p><strong>setDaemon(): 守护线程，主线程退出时，需要子线程随主线程退出</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">num</span>):</span> <span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">    print(<span class="string">&quot;running on number:%s&quot;</span> %num)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    t = threading.Thread(target=sayhi,args=(<span class="string">&#x27;t-%s&#x27;</span>%i,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>)  <span class="comment">#把当前线程变成守护线程，必须在t.start()前设置</span></span><br><span class="line">    t.start()          <span class="comment">#启动一个线程，程序不会阻塞</span></span><br><span class="line">print(<span class="string">&#x27;cost time:&#x27;</span>,time.time() - start_time)</span><br></pre></td></tr></table></figure><p><strong>GIL全局解释器锁：保证同一时间仅有一个线程对资源有操作权限</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">作用：在一个进程内，同一时刻只能有一个线程执行&#96;</span><br><span class="line">&#96;说明：python多线程中GIL锁只是在CPU操作时（如：计算）才是串行的，其他都是并行的，所以比串行快很多</span><br></pre></td></tr></table></figure><ol><li>为了解决不同线程同时访问同一资源时，数据保护问题，而产生了GIL</li><li>GIL在解释器的层面限制了程序在同一时间只有一个线程被CPU实际执行，而不管你的程序里实际开了多少条线程</li><li>CPython自己定义了一个全局解释器锁，同一时间仅仅有一个线程可以拿到这个数据</li><li>python之所以会产生这种不好的状况是因为python启用一个线程是调用操作系统原生线程，就是C接口</li><li>但是这仅仅是CPython这个版本的问题，在PyPy，中就没有这种缺陷</li></ol><p><strong>线程锁</strong>:</p><ol><li>当一个线程对某个资源进行CPU计算的操作时加一个线程锁，只有当前线程计算完成主动释放锁，其他线程才能对其操作</li><li>这样就可以防止还未计算完成，释放GIL锁后其他线程对这个资源操作导致混乱问题</li><li>线程锁本质把线程中的数据加了一把互斥锁</li></ol><h4 id="有了GIL全局解释器锁为什么还需要线程锁"><a href="#有了GIL全局解释器锁为什么还需要线程锁" class="headerlink" title="有了GIL全局解释器锁为什么还需要线程锁"></a>有了GIL全局解释器锁为什么还需要线程锁</h4><p>因为cpu是分时使用的</p><p>GIL是限制同一个进程中只有一个线程进入Python解释器。。。。。<br>而线程锁是由于在线程进行数据操作时保证数据操作的安全性(同一个进程中线程之间可以共用信息，如果同时对数据进行操作，则会出现公共数据错误)<br>其实线程锁完全可以替代GIL，但是Python的后续功能模块都是加在GIL基础上的，所以无法更改或去掉GIL,这就是Python语言最大的bug…只能用多进程或协程改善，或者直接用其他语言写这部分</p><h4 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h4><p>两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去</p><p><strong>用户锁</strong>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">lock = threading.Lock()          <span class="comment">#1 生成全局锁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span>():</span></span><br><span class="line">    <span class="keyword">global</span> num                  <span class="comment">#2 在每个线程中都获取这个全局变量</span></span><br><span class="line">    print(<span class="string">&#x27;--get num:&#x27;</span>,num )</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    lock.acquire()              <span class="comment">#3 修改数据前加锁</span></span><br><span class="line">    num  -= <span class="number">1</span>                   <span class="comment">#4 对此公共变量进行-1操作</span></span><br><span class="line">    lock.release()              <span class="comment">#5 修改后释放</span></span><br></pre></td></tr></table></figure><p><strong>Semaphore(信号量)</strong>:</p><ol><li>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据</li><li>比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去</li><li>作用就是同一时刻允许运行的线程数量</li></ol><p><strong>多线程</strong></p><ul><li><p>GIL锁：</p><p>全局解释锁，每次只能一个线程获得cpu的使用权：为了线程安全，也就是为了解决多线程之间的数据完整性和状态同步而加的锁，因为我们知道线程之间的数据是共享的。</p></li><li><p>join()作用：</p><p>在进程中可以阻塞主进程的执行, 直到等待子线程全部完成之后, 才继续运行主线程后面的代码</p></li><li><p>setDaemon()：</p><p>将该线程标记为守护线程或用户线程</p></li></ul><p><strong>线程池</strong></p><ul><li>使用以下模块创建线程池：</li></ul><ol><li>使用threadpool模块，这是个python的第三方模块，支持python2和python3</li><li>使用concurrent.futures模块，这个模块是python3中自带的模块，但是，python2.7以上版本也可以安装使用</li></ol><ul><li>线程池实现并发:</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line">import requests</span><br><span class="line">from concurrent.futures import ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">def fetch_request(url):</span><br><span class="line">    result &#x3D; requests.get(url)</span><br><span class="line">    print(result.text)</span><br><span class="line"></span><br><span class="line">url_list &#x3D; [</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.baidu.com&#39;,</span><br><span class="line">    &#39;https:&#x2F;&#x2F;www.google.com&#x2F;&#39;,         #google页面会卡住，知道页面超时后这个进程才结束</span><br><span class="line">    &#39;http:&#x2F;&#x2F;dig.chouti.com&#x2F;&#39;,          #chouti页面内容会直接返回，不会等待Google页面的返回</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">pool &#x3D; ThreadPoolExecutor(10)            # 创建一个线程池，最多开10个线程</span><br><span class="line">for url in url_list:</span><br><span class="line">    pool.submit(fetch_request,url)       # 去线程池中获取一个线程，线程去执行fetch_request方法</span><br><span class="line"></span><br><span class="line">pool.shutdown(True)                      # 主线程自己关闭，让子线程自己拿任务执行</span><br></pre></td></tr></table></figure><hr><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><strong>什么是协程（进入上一次调用的状态）</strong></p><ol><li>协程，又称微线程，纤程，协程是一种用户态的轻量级线程。</li><li>线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈，</li><li>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈</li><li>协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态</li><li>协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）</li><li>协程能在单线程处理高并发</li></ol><p><strong>协程的定义</strong>：</p><ol><li>协程在单线程下实现并发效果</li><li>协程遇IO自动切换</li><li>协程保留上一次调用状态</li></ol><p><strong>协程的优点</strong>:</p><ol><li>无需线程上下文切换的开销</li><li>无需原子操作锁定及同步的开销，因为协程是串行的</li><li>方便切换控制流，简化编程模型</li><li>高并发，高扩展，低成本，一个cpu支持上万个协程没有问题，所以非常适合高并发处理</li></ol><p><strong>协程的缺点</strong>:</p><ol><li>无法利用多核的优势，但是协程和进程配合就可以使协程运行在不同的cpu上，就可以利用 多核的优势，但是在现实中，大部分场景都没有这个需要</li><li>只要一个协程阻塞（Blocking），就会阻塞整个协程，因为协程是串行的,这个问题必须要解决，才能让协程大范围应用</li></ol><ul><li>解决方法：<br>如果遇到<strong>io</strong>操作，则进行协程切换,去执行其他的协程，可以用<strong>gevent</strong>来实现，具体的实现是这样的，<br>比如协程1通过os去读一个file，这个时候就是一个 io操作，在调用os的接口前，就会有一个列表，协议1的这个操作就会被注册到这个列表中，然后就切换到其他协程去处理；等待os拿到要读file后，也会把这个文件句柄放在这个列表中，然后等待在切换到<br>协程1的时候，协程1就可以直接从列表中拿到数据，这样就可以实现不阻塞了</li></ul><p><strong>协程处理并发</strong>：</p><ul><li><strong>Gevent<br>遇IO自动切换</strong></li></ul><ol><li>Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程</li><li>协程之所以快是因为遇到I/O操作就切换（最后只有CPU运算）</li><li>其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换</li></ol><ul><li><strong>Greenlet<br>遇IO手动切换</strong></li></ul><ol><li>Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</li></ol><p><strong>使用协程处理并发</strong><br><code>注：Gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line"></span><br><span class="line">monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些请求谁先回来就先处理谁</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch_async</span>(<span class="params">method, url, req_kwargs</span>):</span></span><br><span class="line">    response = requests.request(method=method, url=url, **req_kwargs)</span><br><span class="line">    print(response.url, response.content)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">##### 发送请求 #####</span></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://www.python.org/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://www.google.com/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">    gevent.spawn(fetch_async, method=<span class="string">&#x27;get&#x27;</span>, url=<span class="string">&#x27;https://github.com/&#x27;</span>, req_kwargs=&#123;&#125;),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="select、poll、epoll（重点）："><a href="#select、poll、epoll（重点）：" class="headerlink" title="select、poll、epoll（重点）："></a>select、poll、epoll（重点）：</h5><h4 id="I-O的实质是什么？"><a href="#I-O的实质是什么？" class="headerlink" title="I/O的实质是什么？"></a>I/O的实质是什么？</h4><p>I/O的实质是将硬盘中的数据，或收到的数据实现从内核态 copy到 用户态的过程<br>本文讨论的背景是Linux环境下的network IO。<br>比如微信读取本地硬盘的过程<br>微信进程会发送一个读取硬盘的请求—-》操作系统<br>只有内核才能够读取硬盘中的数据—》数据返回给微信程序（看上去就好像是微信直接读取）</p><h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>系统空间分为两个部分，一部分是内核态，一部分是用户态的部分<br>内核态：内核态的空间资源只有操作系统能够访问<br>用户态：我们写的普通程序使用的空间</p><p><img src="https://img-blog.csdnimg.cn/20200224132553804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200224132633111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>select （能监控数量有限，不能告诉用户程序具体哪个连接有数据）</strong></li></ul><p>单个进程就可以同时处理多个网络连接的io请求（同时阻塞多个io操作）。基本原理就是程序呼叫select，然后整个程序就阻塞状态，这时候，kernel内核就会轮询检查所有select负责的文件描述符fd，当找到其中那个的数据准备好了文件描述符，会返回给select，select通知系统调用，将数据从kernel内核复制到进程缓冲区(用户空间)。</p><ul><li><strong>poll（和select一样，仅仅去除了最大监控数量）</strong></li></ul><ol><li>poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制<br>差别如下：</li></ol><p>描述fd集合的方式不同，poll使用 pollfd 结构而不是select结构fd_set结构，所以poll是链式的，没有最大连接数的限制<br>poll有一个特点是水平触发，也就是通知程序fd就绪后，这次没有被处理，那么下次poll的时候会再次通知同个fd已经就绪。</p><ul><li><strong>epoll (不仅没有最大监控数量限制，还能告诉用户程序哪个连接有活跃)</strong><br><code>注：epoll被认为是linux下性能最好的多路io就绪通知方法</code></li></ul><ol><li>epoll直到Linux2.6（centos6以后）才出现了由内核直接支持</li><li>Epoll没有最大文件描述符数量限制</li><li>epoll最重要的优点是他可以直接告诉用户程序哪一个，比如现在用epoll去监控10000个socket链接，交给内核去监测，现在有一个连接有数据了，在有有一个连接有数据了，epoll会直接高数用户程序哪个连接有数据了</li></ol><p>epoll是select和poll的改进方案，在 linux 上可以取代 select 和 poll，可以处理大量连接的性能问题</p><ul><li><strong>epoll能实现高并发原理</strong></li></ul><ol><li><p>epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。</p></li><li><p>在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。</p></li><li><p>某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，把这个 sockfd 加入链表。</p></li><li><p>epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销<br>内存映射（mmap）：内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作</p><p><strong>epoll有4个动作：创建，注册，等待，取消注册，很显然我们用不着</strong></p></li></ol><ul><li><p><strong>epoll和select，poll还有一个本质的区别的就是:</strong></p><p>select 和 poll 只有在下次在循环回来，再去操作系统获取文件描述符<br>epoll 会直接告诉程序，我们这里已经就绪了，你可以接受数据了，等下一次协程去调用 epoll_wait 的时候就可以直接拿到就绪的文件描述符</p></li></ul><p><strong>猴子补丁</strong></p><p>即在运行时对方法 / 类 / 属性 / 功能进行修改，把新的代码作为解决方案代替原有的程序，也就是为其打上补丁。</p><p>在使用gevent模块的使用会遇到猴子补丁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent.monkey</span><br><span class="line"> </span><br><span class="line">gevent.monkey.patch_all()</span><br><span class="line"></span><br><span class="line">注解：使用猴子补丁的方式，gevent能够修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。也就是通过猴子补丁的monkey.patch_xxx()来将python标准库中模块或函数改成gevent中的响应的具有协程的协作式对象。这样在不改变原有代码的情况下，将应用的阻塞式方法，变成协程式的。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><strong>介绍</strong></p><p>装饰器(Decorators)是 Python 的一个重要部分。<br>简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。</p><p><strong>装饰器的概念</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 装饰器实际上就是一个函数</span><br><span class="line">2. 有2个特别之处，参数是一个函数。返回值是一个参数</span><br><span class="line">12</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>装饰器的简单理解</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">实际上就是为了给一个程序添加功能，但是该程序已经上线或者已被使用，</span><br><span class="line">那么就不能大批量的修改源码，这样不现实，因此就产生了装饰器。</span><br><span class="line">注意点：</span><br><span class="line">1. 不能修改被装饰的函数的源代码</span><br><span class="line">2. 不能修改被装饰的函数的调用方式</span><br><span class="line">12345</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>装饰器组成方式</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">函数+实参高阶函数+返回值高阶函数+嵌套函数+语法糖 &#x3D; 装饰器</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>有关高阶函数的理解</strong>：</p><ol><li>把一个函数名当作实参传给另外一个函数（”实参高阶函数“）</li><li>返回值中包含函数名（”返回值高阶函数“）</li></ol></li><li><p><strong>嵌套函数的理解</strong>：</p><p>嵌套函数指的是在函数内部定义一个函数，而不是调用。</p></li><li><p><strong>语法糖</strong>：</p><p>写法：@xx ，一般写在函数的上方</p></li></ul><p><strong>装饰器实例</strong></p><ul><li><p><strong>使用高阶函数模拟装饰器:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">start_time = time.time()</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;函数执行时间为&#x27;</span>, time.time() - start_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;开始执行test&#x27;</span></span><br><span class="line">time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;test执行结束&#x27;</span></span><br><span class="line">timer(test)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">开始执行test</span></span><br><span class="line"><span class="string">test执行结束</span></span><br><span class="line"><span class="string">函数执行时间为 3.00332999229</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>计算运行时间装饰器:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span>   <span class="comment">#timer(test1)  func=test1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#run test1</span></span><br><span class="line">        stop_time = time.time()</span><br><span class="line">        print(<span class="string">&quot;running time is %s&quot;</span>%(stop_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"><span class="meta">@timer     # test1=timer(test1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;in the test1&quot;</span>)</span><br><span class="line">test1()</span><br><span class="line"><span class="number">12345678910111213</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>装饰无参函数，示例代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器装饰的函数无参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span>      <span class="comment">#func其实指的就是test</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>():</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func()               <span class="comment">#这里其实是对test的调用</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer               #test函数使用装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&quot;test is running&quot;</span>)</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running</span><br><span class="line"><span class="number">2.003510952</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>装饰有参函数，示例代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器装饰的函数有参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">*args,**kwargs</span>):</span>    <span class="comment">#添加可变参数*args和**kwargs</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        func(*args,**kwargs)      <span class="comment">#这里也是一样，添加可变参数*args和**kwargs</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        <span class="keyword">print</span> (stop-start)</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">value</span>):</span>     <span class="comment">#test函数有个参数value,正因为装饰器timer装饰的函数test有参数value,因此在timer中的有了可变参数</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">&quot;test is running %s&quot;</span> %value)</span><br><span class="line">test(<span class="string">&quot;22&quot;</span>)</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line">test <span class="keyword">is</span> running <span class="number">22</span></span><br><span class="line"><span class="number">2.00424408913</span></span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>带参数的装饰器，示例代码如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#装饰器带参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">parameter</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">out_wapper</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wapper</span>(<span class="params">*wargs,**kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> parameter == <span class="string">&quot;task1&quot;</span>:</span><br><span class="line">                start = time.time()</span><br><span class="line">                func(*wargs,**kwargs)</span><br><span class="line">                stop = time.time()</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">&quot;the task1 is run:&quot;</span>,stop-start)</span><br><span class="line">            <span class="keyword">elif</span> parameter == <span class="string">&quot;task2&quot;</span>:</span><br><span class="line">                func(*wargs, **kwargs)</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">&quot;the task2 is run:&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> wapper</span><br><span class="line">    <span class="keyword">return</span> out_wapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = &quot;task1&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;in the task1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer(parameter = &quot;task2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;in the task2&quot;</span></span><br><span class="line"></span><br><span class="line">task1()</span><br><span class="line">task2()</span><br><span class="line"></span><br><span class="line">打印结果：</span><br><span class="line"><span class="keyword">in</span> the task1</span><br><span class="line">(<span class="string">&#x27;the task1 is run:&#x27;</span>, <span class="number">2.002906084060669</span>)</span><br><span class="line"><span class="keyword">in</span> the task2</span><br><span class="line">the task2 <span class="keyword">is</span> run:</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930313233</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>装饰器使用场景</strong></p><blockquote><p>授权：装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中<br>日志：在记录日志的地方添加装饰器<br>缓存：通过装饰器获取缓存中的值</p></blockquote><p><strong>闭包</strong></p><ul><li><p><strong>定义</strong>：</p><p>如果在一个函数的内部定义了另一个函数，外部的我们叫他外函数，内部的我们叫他内函数。那闭包就是，在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包</p></li></ul><hr><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>定义</strong>:</p><ol><li>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</li><li>迭代器是一个可以记住遍历的位置的对象。</li><li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</li><li>迭代器有两个基本的方法：iter() 和 next()。</li><li>字符串，列表或元组对象都可用于创建迭代器：</li></ol><p><strong>可迭代对象</strong>:</p><p>在Python世界里，一切皆对象。对象根据定义的维度，又可以分为各种不同的类型，比如：文件对象，字符串对象，列表对象。。。等等。<br>一句话：“实现了__inter__方法的对象就叫做可迭代对象”，__inter__方法的作用就是返回一个迭代器对象。<br>直观理解就是能用for循环进行迭代的对象就是可迭代对象。比如：字符串，列表，元祖，字典，集合等等，都是可迭代对象。</p><p><strong>next()与iter()</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">next()返回迭代器的下一个项目</span><br><span class="line">next语法:</span><br><span class="line">next(iterator[,dafault])</span><br><span class="line"></span><br><span class="line">iterator -- 可迭代对象</span><br><span class="line">default -- 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 StopIteration 异常。</span><br><span class="line"></span><br><span class="line">iter():</span><br><span class="line">iter()函数用来生成迭代器</span><br><span class="line">iter语法:</span><br><span class="line">12345678910</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>迭代器实现斐波那契</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fib</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        self.a = <span class="number">0</span></span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">        self.n = n</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span>(<span class="params">self</span>):</span></span><br><span class="line">        res = self.a</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        <span class="keyword">if</span> self.count &gt; self.n:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">print(list(Fib(<span class="number">5</span>)))</span><br><span class="line">print(list(Fib(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><strong>生成器和迭代器之间的区别</strong></p><p>在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字‘yield’来每次生成/返回一个对象。 生成器中有多少‘yield’语句，你可以自定义。 每次‘yield’暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。</p></li></ul><hr><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><ul><li><p><strong>生成器定义、简介</strong></p><p>在python中，生成器是根据某种算法边循环边计算的一种机制。主要就是用于操作大量数据的时候，<br>一般我们会将操作的数据读入内存中处理，可以计算机的内存是比较宝贵的资源，我认为的当要处理的数据超过内存四分之一的大小时就应该使用生成器。</p></li><li><p><strong>生成器的作用</strong></p></li></ul><ol><li><p>通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。</p></li><li><p>而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p></li><li><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？</p></li><li><p>这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p></li></ol><ul><li><strong>特点</strong></li></ul><ol><li><p>和传统的容器相比，生成器更节省内存。</p></li><li><p>延迟计算，在我们需要结果时就调用一下生成器的next()方法即可。</p></li><li><p>可迭代，你可以像遍历list一样，遍历生成器</p></li></ol><ul><li><strong>生成器工作原理</strong></li></ul><ol><li><p>生成器是这样一个函数，它记住上一次返回时在函数体中的位置。</p></li><li><p>对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。</p></li><li><p>生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造中的位置。</p></li><li><p>生成器是一个函数，而且函数的参数都会保留。</p></li><li><p>迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的</p><p><strong>在python中有两种方式创建生成器：生成器表达式 和 生成器函数。</strong></p></li></ol><ul><li><strong>生成器 和 普通函数的区别 ？</strong></li></ul><p>生成式函数和普通函数只有一个区别，普通函数使用return返回结果，而生成器函 数使用yield返回结果。<br>yield的特点在于，它并不是结束函数，而是在返回结果后将函数处于一种挂起状态，等待再次next函数的调用，然后从上次挂起的地方(yield)继续执行。</p><ul><li><strong>可迭代的数据类型</strong></li></ul><p>列表、元组、字典和集合都是可迭代的对象，可以从其中获得迭代器。<br>所有这些对象都可用iter()方法获取迭代器:</p><ul><li><p><strong><code>yield运行机制</code></strong>:</p><p>在Python中，yield就是这样的一个生成器。</p></li></ul><ol><li>当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。</li><li>当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复</li><li>在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器</li><li>它的执行会和其他普通的函数有很多不同，函数返回的是一个对象，而不是你平常所用return语句那样，能得到结果值。如果想取得值，那得调用next()函数</li><li>每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">max_num</span>):</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; max_num:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a,b=b,a+b</span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">10</span>)               <span class="comment">#生成一个生成器：[1，2, 3, 5, 8, 13]</span></span><br><span class="line">print(g.__next__())       <span class="comment">#第一次调用返回：1</span></span><br><span class="line">print(list(g))            <span class="comment">#把剩下元素变成列表：[2, 3, 5, 8, 13]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次执行send()或next()只是返回了对应yield表达式的参数值，其实对应表达式并未执行，直到下次再执行send()或next()才会执行上次返回参数的yield表达式，所谓的执行yield表达式就是给其赋值，并返回下一个yield表达式的参数值！<br><a href="https://www.jianshu.com/p/36168970b0eb">yield机制详细地址</a></p><hr><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>简介</strong>：</p><p>面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。<br>其实面向对象也很简单，却也很难，熟能生巧。你需要了解类和对象，要学会定义类，创建对象。</p><p><strong>特点</strong>：</p><ol><li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li><li>方法：类中定义的函数。</li><li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li><li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li><li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li><li>局部变量：定义在方法中的变量，只作用于当前实例的类。</li><li>实例变量：在类的声明中，属性是用变量来表示的，这种变量就称为实例变量，实例变量就是一个用 self 修饰的变量。</li><li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。</li><li>实例化：创建一个类的实例，类的具体对象。</li><li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面详细介绍:</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h3><p><strong>1.1 静态方法</strong>：</p><ul><li>定义：使用装饰器@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</li><li>调用：实例对象和类对象都可以调用。</li><li>特性: 静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性</li><li>作用：静态方法可以更好的组织代码，防止代码变大后变得比较混乱。</li><li>静态方法使用场景：<ol><li>我们要写一个只在类中运行而不在实例中运行的方法.</li><li>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法.</li><li>比如更改环境变量或者修改其他类的属性等能用到静态方法.</li><li>这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">        print(<span class="string">&quot;I am a static method&quot;</span>)</span><br><span class="line">d = Dog(<span class="string">&quot;ChenRonghua&quot;</span>)</span><br><span class="line">d.eat()                     <span class="comment">#方法1：使用实例调用</span></span><br><span class="line"></span><br><span class="line">Dog.eat()                   <span class="comment">#方法2：使用类直接调用</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>1.2 类方法</strong>：</p><ul><li>定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</li><li>调用：实例对象和类对象都可以调用。</li><li>作用：无需实例化直接被类调用</li><li>类方法使用场景： 当我们还未创建实例，但是需要调用类中的方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">object</span>):</span></span><br><span class="line">    name = <span class="string">&#x27;类变量&#x27;</span> <span class="comment">#在这里如果不定义类变量仅定义实例变量依然报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = <span class="string">&#x27;实例变量&#x27;</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self,food</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s is eating %s&quot;</span>%(self.name,food))</span><br><span class="line">Dog.eat(<span class="string">&#x27;baozi&#x27;</span>)                   <span class="comment">#方法1：使用类直接调用</span></span><br><span class="line">d = Dog(<span class="string">&quot;ChenRonghua&quot;</span>)          </span><br><span class="line">d.eat(<span class="string">&quot;包子&quot;</span>)                      <span class="comment">#方法2：使用实例d调用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>1.3 实例方法</strong>：</p><ul><li>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</li><li>调用：只能由实例对象调用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot; %s is eating&quot;</span> % self.name)</span><br><span class="line">d = Dog(<span class="string">&quot;ChenRonghua&quot;</span>)</span><br><span class="line">d.eat()</span><br><span class="line"><span class="comment"># 调用会出以下错误， 说NoneType is not callable, 因为eat此时已经变成一个静态属性了， </span></span><br><span class="line"><span class="comment"># 不是方法了， 想调用已经不需要加()号了，直接d.eat就可以了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="1-4-魔法方法"><a href="#1-4-魔法方法" class="headerlink" title="1.4 魔法方法:"></a>1.4 魔法方法:</h5><p>我们在调用python类中的某个方法时，通常会看到某些特殊的方法，它们总被双下划线所包围，像这种格式：”<strong>方法名</strong>“，这些方法很强大，充满魔力，可以让你实现很多功能。，如果你的对象实现（重载）了这些方法中的某一个，那么这个方法就会在特殊的情况下被 Python 所调用，你可以定义自己想要的行为，而这一切都是自动发生的。因此了解这类方法的作用及用户很有必要，以下对基本魔法方法做出总结，请看：<a href="https://www.jianshu.com/p/2ec468e58b89">魔法方法表格</a></p><p>type生成类调用顺序:</p><p><strong>new</strong> : 先于<strong>init__方法，每生成一个实例执行一次，<strong>new</strong> 类方法创建实例对象<br>__init</strong> : <strong>init__方法每生成一个实例就会执行一次，初始化实例对象<br>__call</strong> : 后与<strong>init__方法，C()() 使用类再加一个括号调用， C为类名称<br>__del</strong> : 析构方法，删除无用的内存对象（当程序结束会自动自行析构方法）</p><p><strong>类实例化时魔法方法调用顺序</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;__new__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)   <span class="comment"># 必须返回父类的__new__方法，否则不不执行__init__方法，无法创建实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;__init__&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span>                <span class="comment"># 作用：打印实例时显示指定字符串，而不是内存地址</span></span><br><span class="line">        print(<span class="string">&#x27;__str__&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span>        <span class="comment"># 当执行C()(*args) 或者 s1(*args) 就会执行__call__</span></span><br><span class="line">        print(<span class="string">&#x27;__call__&#x27;</span>,*args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span>                <span class="comment"># 作用：清除无用的实例对内存的暂用</span></span><br><span class="line">        print(<span class="string">&#x27;__del__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#1、实例化时机会执行__new__、__init__</span></span><br><span class="line">s1 = Student(<span class="string">&#x27;tom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、执行 实例()  就会执行__call__ 方法，并将参数传递给__call__函数</span></span><br><span class="line">s1(<span class="string">&#x27;call01&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、当打印实例时就会执行 __str__ 方法下返回的字符串（默认返回的实例地址）</span></span><br><span class="line">print(s1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#4、析构方法：当删除实例时就会调用 __del__ 方法</span></span><br><span class="line"><span class="keyword">del</span> s1</span><br><span class="line"><span class="comment"># 析构方法作用：在程序结束后会自动执行析构方法删除所有实例</span></span><br><span class="line"><span class="comment"># 但是在程序运行时有很多实例是无用的，但是python内存回收机制却不会自动删除他们，这样就浪费内存</span></span><br><span class="line"><span class="comment"># 我们可以执行 del s1 ，那么在程序运行时，python内存回收机制会检测到这些实例时无用的，才会删除</span></span><br><span class="line"><span class="comment"># 其实我们执行del s1，并没有回收内存，只不过是摘除门牌号，python内存回收机制发现没有门牌号后会自动回收内存</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><strong>new</strong> &amp; __init__详解</strong>:</p><ol><li><strong>new</strong> 至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动 提供</li><li><strong>new</strong> 必须要有返回值，返回实例化出来的实例，这点在自己实现 <strong>new</strong> 时要特别注 意，可以return父类 <strong>new</strong> 出来的实例，或者直接是object的 <strong>new</strong> 出来的实例</li><li><strong>init</strong> 有一个参数self，就是这个 <strong>new</strong> 返回的实例， <strong>init</strong> 在 <strong>\new</strong> 的基础上 可以完成一些其它初始化的动作， <strong>init</strong> 不需要返回值 我们可以将类比作制造商， <strong>new</strong> 方法就是前期的原材料购买环节， <strong>init</strong> 方法就是在 有原材料的基础上，加工，初始化商品环节。</li></ol><h4 id="1-5-单例模式："><a href="#1-5-单例模式：" class="headerlink" title="1.5 单例模式："></a>1.5 单例模式：</h4><p>__new__方法书写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">print(self)</span><br><span class="line">print(<span class="string">&quot;这是 init 方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">print(id(cls))</span><br><span class="line">print(<span class="string">&quot;这是 __new__ 方法&quot;</span>)</span><br><span class="line">ret = object.__new__(cls)</span><br><span class="line">print(res)</span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(id(A))</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">--&gt;: 12345678987654321</span><br><span class="line">这是 new 方法</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br><span class="line">--&gt;: &lt;__main__.A object at 0x105b96ac8&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="线程安全的单例"><a href="#线程安全的单例" class="headerlink" title="线程安全的单例:"></a>线程安全的单例:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">线程安全的单利模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">紧跟with后面的语句被求值后，返回对象的 __enter__() 方法被调用，这个方法的返回值将被赋值给as后面的变量。</span></span><br><span class="line"><span class="string">当with后面的代码块全部被执行完之后，将调用前面返回对象的 __exit__()方法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronized</span>(<span class="params">func</span>):</span></span><br><span class="line">    func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lock_func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">with</span> func.__lock__:</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lock_func</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">object</span>):</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls</span>):</span></span><br><span class="line">        <span class="comment"># 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.instance:</span><br><span class="line">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先看类，可以看出这里我们先定义了一个类属性instance，接着我们重写了父类的__new__方法，这个方法就是我们在实例化一个对象时最先调用的一个方法。和其他静态语言不一样，其他静态语言，直接调用了构造方法，一般情况下初始化的程序也写在构造方法之中。而python实例化一个对象和初始化是分开的。__new__是类方法，__init__是实例方法，也就是说，__init__是在对象已经创建完成之后，才执行。</p><p>在python3中，调用父类的方法是用super()来调用。所以我们这里的思路就是，还是用父类的方法去创造，但是我们要加一个判断，就是说，当这个对象也就是类属性并不为空的时候，我们就不在实例化，而是返回一个已经实例化的类属性。</p><h4 id="线程不安全的单例"><a href="#线程不安全的单例" class="headerlink" title="线程不安全的单例"></a>线程不安全的单例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>(<span class="params">object</span>):</span></span><br><span class="line">__instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, age</span>):</span></span><br><span class="line"><span class="comment"># 如果类属性__instance的值为None，那么就创建一个对象</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cls.__instance:</span><br><span class="line">cls.__instance = object.__new__(cls)</span><br><span class="line"><span class="comment"># 如果已经有实例存在，直接返回</span></span><br><span class="line"><span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Singleton(<span class="string">&quot;Zhangsan&quot;</span>, <span class="number">18</span>)</span><br><span class="line">b = Singleton(<span class="string">&quot;lisi&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line">a.age = <span class="number">30</span>   <span class="comment"># 给a指向的对象添加一个属性</span></span><br><span class="line">print(b.age)  <span class="comment"># 获取b指向的对象的age属性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong><strong>del</strong></strong></p><p>Python 通过调用 <strong>init</strong>() 方法构造当前类的实例化对象，而 <strong>del</strong>() 方法，功能正好和 <strong>init</strong>() 相反，其用来销毁实例化对象。</p><p>事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。<br>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。</p><p>无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 <strong>del</strong>() 方法。</p><h3 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h3><h4 id="面向对象三大特性-封装，继承，多态"><a href="#面向对象三大特性-封装，继承，多态" class="headerlink" title="面向对象三大特性: 封装，继承，多态"></a><code>面向对象三大特性: 封装，继承，多态</code></h4><h4 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装:"></a>2.1 封装:</h4><ol><li>在类中对数据的赋值、内部调用对外部用户是透明的</li><li>这使类变成了一个胶囊或容器，里面包含着类的数据和方法</li><li>作用：<ul><li>防止数据被随意修改<ul><li>使外部程序不需要关注对象内部的构造，只需要通过对外提供的接口进行直接访问</li></ul></li></ul></li></ol><p><strong>继承的种类</strong></p><ol><li>单继承：一个类继承单个基类</li><li>多继承:一个类继承多个基类</li><li>多级继承：一个类继承自单个基类，后者继承自另一个基类</li><li>分层继承：多个类继承自单个基类</li><li>混合继承：两种或多种类型继承的混合</li></ol><p><strong>封装的好处：</strong></p><ol><li>将变化隔离</li><li>便于使用</li><li>提高复用性</li><li>提高安全性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装：将数据进行封装到对象中，以供其他函数进行调用</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-2-Inheritance-继承（代码重用"><a href="#2-2-Inheritance-继承（代码重用" class="headerlink" title="2.2 Inheritance 继承（代码重用:"></a>2.2 Inheritance 继承（代码重用:</h4><ol><li>一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承</li><li>比如CS中的警察和恐怖分子，可以将两个角色的相同点写到一个父类中，然后同时去继承它</li><li>使用经典类： Person.<strong>init</strong>(self, name, age) 并重写写父类Person的构造方法，实现，先覆盖，再继承，再重构</li></ol><p><strong>继承的优点：</strong></p><ol><li>节省代码,减少代码的重复性</li><li>增强耦合性(也就是增强代码可读性)</li><li>使代码更加规范化</li><li>子类可以调用父类的所有属性</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">D</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;B&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">D</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">B,C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># def talk(self):</span></span><br><span class="line">    <span class="comment">#     print(&#x27;A&#x27;)</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.talk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 黑人，白人都继承父类Person就可以都有父类的属性和方法了</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span>  <span class="comment">#执行Person.__init__(self,name,age)时就会将传入的参数执行一遍</span></span><br><span class="line">        self.name = name          <span class="comment">#所以在BlackPerson中不仅有name,age而且还有sex</span></span><br><span class="line">        self.age = age</span><br><span class="line">        self.sex = <span class="string">&quot;normal&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;person is talking....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span>(<span class="params">Person</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age,strength</span>):</span>     <span class="comment">#先覆盖，再继承，再重构</span></span><br><span class="line">        <span class="comment">#先覆盖父类的__init__方法，再继承父类__init__，再加自己的参数</span></span><br><span class="line">        Person.__init__(self,name,age)        <span class="comment">#先继承父类Person，这里self就是BlackPerson本身</span></span><br><span class="line">        <span class="comment">#先将name,age传给子类BlackPerson,然后调用Person.__init__构造方法将参数出入父类（）</span></span><br><span class="line">        self.strength = strength              <span class="comment">#然后再重构自己的方法,即写自己的参数</span></span><br><span class="line">        print(self.name,self.age,self.sex)</span><br><span class="line">        print(self.strength)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;black balabla&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">walk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;is walking....&quot;</span>)</span><br><span class="line"></span><br><span class="line">b = BlackPerson(<span class="string">&quot;wei er smith&quot;</span>,<span class="number">22</span>,<span class="string">&quot;Strong&quot;</span>)</span><br><span class="line">b.talk()</span><br><span class="line">b.walk()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># wei er smith 22 normal</span></span><br><span class="line"><span class="comment"># Strong</span></span><br><span class="line"><span class="comment"># black balabla</span></span><br><span class="line"><span class="comment"># is walking....</span></span><br><span class="line"><span class="comment"># person is talking....</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>新式类经典类区别：</strong></p><p>Python 2.x中默认都是经典类，只有显式继承了object才是新式类<br>Python 3.x中默认都是新式类，不必显式的继承object<br>当类是经典类时，多继承情况下，会按照深度优先方式查找<br>当类是新式类时，多继承情况下，会按照广度优先方式查找</p><h4 id="2-3-Polymorphism-多态（接口重用）"><a href="#2-3-Polymorphism-多态（接口重用）" class="headerlink" title="2.3 Polymorphism 多态（接口重用）"></a>2.3 Polymorphism 多态（接口重用）</h4><ol><li>多态是面向对象的重要特性,简单点说:“一个接口，多种实现”</li><li>指一个基类中派生出了不同的子类，且每个子类在继承同样的方法名的同时又对父类的方法做了不同的实现</li><li>这就是同一种事物表现出的多种形态</li><li>比如黄种人继承了人talk这个功能，但是他说的是中文，而美国人的talk是英文，但是他们是同样的talk</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">作用：简单的讲就是允许父类调用子类的方法</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很多人喜欢将多态与多态性二者混为一谈，然后百思不得其解，其实只要分开看，就会很明朗。</p><ol><li>多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）</li><li>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多态举例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>    <span class="comment"># Constructor of the class</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span>              <span class="comment"># Abstract method, defined by convention only</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement abstract method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Meow!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Woof! Woof!&#x27;</span></span><br><span class="line"></span><br><span class="line">animals = [Cat(<span class="string">&#x27;Missy&#x27;</span>),</span><br><span class="line">           Dog(<span class="string">&#x27;Lassie&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    print(animal.name + <span class="string">&#x27;: &#x27;</span> + animal.talk())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line"><span class="comment"># Missy: Meow!</span></span><br><span class="line"><span class="comment"># Lassie: Woof! Woof!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Python中多态的特点</strong></p><ol><li>只关心对象的实例方法是否同名，不关心对象所属的类型；</li><li>对象所属的类之间，继承关系可有可无；</li><li>多态的好处可以增加代码的外部调用灵活度，让代码更加通用，兼容性比较强；</li><li>多态是调用方法的技巧，不会影响到类的内部设计。</li></ol><h3 id="3-属性"><a href="#3-属性" class="headerlink" title="3. 属性"></a>3. 属性</h3><ol><li><strong>类的公有属性</strong><br>public_attrs：能在类的外部被使用或直接访问。在类内部的方法中使用时 public_attrs_attrs，在类的外部class_name.public_attrs。</li><li><strong>类的私有属性</strong><br>__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。</li><li><strong>类的(公有)方法</strong><br>在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。<br>self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。</li><li><strong>类的私有方法</strong><br>__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。</li></ol><h3 id="4-反射-hasattr、getattr、setattr-和-delattr"><a href="#4-反射-hasattr、getattr、setattr-和-delattr" class="headerlink" title="4. 反射: hasattr、getattr、setattr 和 delattr"></a>4. 反射: hasattr、getattr、setattr 和 delattr</h3><p>在做程序开发中，我们常常会遇到这样的需求：需要执行对象里的某个方法，或需要调用对象中的某个变量，但是由于种种原因我们无法确定这个方法或变量是否存在，这是我们需要用一个特殊的方法或机制要访问和操作这个未知的方法或变量，这中机制就称之为反射。</p><p>反射就是通过字符串的形式，导入模块；通过字符串的形式，去模块寻找指定函数，并执行。利用字符串的形式去对象（模块）中操作（查找/获取/删除/添加）成员，一种基于字符串的事件驱动！<br><a href="https://www.cnblogs.com/kongk/p/8645202.html">–反射详解–</a></p><h4 id="四大属性"><a href="#四大属性" class="headerlink" title="四大属性:"></a><code>四大属性:</code></h4><ul><li><p><strong>hasattr(ogj,name_str) 判断一个对象里是否有对应的字符串方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self,food</span>):</span></span><br><span class="line">        print(<span class="string">&quot;eat method!!!&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="comment">#hasattr判断对象d是否有eat方法，有返回True，没有返回False</span></span><br><span class="line">print(hasattr(d,<span class="string">&#x27;eat&#x27;</span>))     <span class="comment">#True</span></span><br><span class="line">print(hasattr(d,<span class="string">&#x27;cat&#x27;</span>))     <span class="comment">#False</span></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>getattr(obj,name_str) 根据字符串去获取obj对象里的对应的方法的内存地址</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;eat method!!!&quot;</span>)</span><br><span class="line">d = Dog()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> hasattr(d,<span class="string">&#x27;eat&#x27;</span>):          <span class="comment"># hasattr判断实例是否有eat方法</span></span><br><span class="line">    func = getattr(d, <span class="string">&#x27;eat&#x27;</span>)  <span class="comment"># getattr获取实例d的eat方法内存地址</span></span><br><span class="line">    func()                    <span class="comment"># 执行实例d的eat方法</span></span><br><span class="line"><span class="comment">#运行结果：  eat method!!!</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>使用stattr给类实例对象动态添加一个新的方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abc</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;汇森&quot;</span>)</span><br><span class="line">setattr(p,<span class="string">&quot;talk&quot;</span>,abc)   <span class="comment"># 将abc函数添加到对象中p中，并命名为talk</span></span><br><span class="line">p.talk(p)               <span class="comment"># 调用talk方法，因为这是额外添加的方法，需手动传入对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果 汇森正在交谈</span></span><br><span class="line"></span><br><span class="line">setattr(p,<span class="string">&quot;age&quot;</span>,<span class="number">30</span>)     <span class="comment"># 添加一个变量age,复制为30</span></span><br><span class="line">print(p.age)            <span class="comment"># 打印结果:30</span></span><br><span class="line"></span><br><span class="line"><span class="number">12345678910111213141516</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>delattr删除对象中的变量。注意：不能用于删除方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;%s正在交谈&quot;</span>%self.name)</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;汇森&quot;</span>)</span><br><span class="line"></span><br><span class="line">delattr(p,<span class="string">&quot;name&quot;</span>)       <span class="comment"># 删除name变量</span></span><br><span class="line">print(p.name)           <span class="comment"># 此时将报错</span></span><br><span class="line"><span class="number">12345678910</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h3><h4 id="1-深拷贝浅拷贝"><a href="#1-深拷贝浅拷贝" class="headerlink" title="1. 深拷贝浅拷贝"></a>1. 深拷贝浅拷贝</h4><p><strong>1.1 预备知识一——python的变量及其存储</strong></p><ol><li>python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的只本身</li><li>不管多么复杂的数据结构，浅拷贝都只会copy一层。<br>理解：两个人公用一张桌子，只要桌子不变，桌子上的菜发生了变化两个人是共同感受的。</li></ol><p><strong>1.2 浅copy与deepcopy</strong></p><ol><li>浅copy： 不管多么复杂的数据结构，浅拷贝都只会copy一层</li><li>deepcopy : 深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">sourceList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line">copyList = copy.copy(sourceList)</span><br><span class="line">deepcopyList = copy.deepcopy(sourceList)</span><br><span class="line"></span><br><span class="line">sourceList[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">100</span></span><br><span class="line"></span><br><span class="line">print(sourceList)           <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(copyList)             <span class="comment"># [1, 2, 3, [100, 5, 6]]</span></span><br><span class="line">print(deepcopyList)         <span class="comment"># [1, 2, 3, [4, 5, 6]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-python垃圾回收机制"><a href="#2-python垃圾回收机制" class="headerlink" title="2. python垃圾回收机制"></a>2. python垃圾回收机制</h4><p><strong>2.1 引用计数:</strong></p><ol><li>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1.</li><li>当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。</li></ol><p><strong>2.2 标记－清除:</strong></p><ol><li>它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。</li><li>对象之间通过引用（指针）连在一起，构成一个有向图</li><li>从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象，根对象就是全局变量、调用栈、寄存器。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注：像是PyIntObject、PyStringObject这些不可变对象是不可能产生循环引用的，因为它们内部不可能持有其它对象的引用。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020012811083048.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5</li><li>第一步将标记块1，并记住块2和3以供稍后处理。</li><li>第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。</li><li>扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。</li></ol><p><strong>2.3 分代回收：</strong></p><ol><li>分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。</li><li>Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）</li><li>他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。</li><li>新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发</li><li>把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推</li><li>老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</li></ol><h4 id="3-上下文管理"><a href="#3-上下文管理" class="headerlink" title="3 上下文管理"></a>3 上下文管理</h4><p><strong>3.1 什么是with语句</strong></p><ol><li>with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。</li><li>所以使用with处理的对象必须有enter()和exit()这两个方法<ol><li>with通过enter方法初始化（enter方法在语句体执行之前进入运行）<ol start="2"><li>然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）</li></ol></li></ol></li></ol><p><strong>3.2 with语句使用场景</strong></p><ol><li>with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源</li><li>比如文件使用后自动关闭、线程中锁的自动获取和释放等。</li></ol><p><strong>3.3 with处理文件操作的实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;/etc/passwd&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">print(line)</span><br><span class="line"><span class="comment"># 这段代码的作用：打开一个文件，如果一切正常，把文件对象赋值给f，然后用迭代器遍历文件中每一行，当完成时，关闭文件；</span></span><br><span class="line"><span class="comment"># 而无论在这段代码的任何地方，如果发生异常，此时文件仍会被关闭。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-高阶函数"><a href="#4-高阶函数" class="headerlink" title="4 高阶函数"></a>4 高阶函数</h4><p><strong>4.1 lambda基本使用</strong></p><ol><li>lambda只是一个表达式，函数体比def简单很多。</li><li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li><li>lambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。</li><li>格式：lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x,y,z:x+y+z</span><br><span class="line">print(f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))                    <span class="comment"># 6</span></span><br><span class="line"></span><br><span class="line">my_lambda = <span class="keyword">lambda</span> arg : arg + <span class="number">1</span></span><br><span class="line">print(my_lambda(<span class="number">10</span>))                <span class="comment"># 11</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.2 三元运算:</strong></p><ol><li>三元运算格式： result=值1 if x&lt;y else 值2 if条件成立result=1,否则result=2</li><li>作用：三元运算，又称三目运算，主要作用是减少代码量，是对简单的条件语句的缩写</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;Tom&#x27;</span> <span class="keyword">if</span> <span class="number">1</span> == <span class="number">1</span> <span class="keyword">else</span> <span class="string">&#x27;fly&#x27;</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># 运行结果： Tom</span></span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span></span><br><span class="line">print(f(<span class="number">10</span>))                    <span class="comment"># 110</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="map-函数用法："><a href="#map-函数用法：" class="headerlink" title="map()函数用法："></a>map()函数用法：</h5><p><strong>map(function, iterable, …)</strong><br><strong>功能：</strong></p><ul><li>将第一个参数 function 依次作用在参数可迭代对象中的每一个元素上，返回包含每次 function 函数返回值的新迭代器</li><li>map() 会根据提供的函数对指定序列做映射。(映射及对应)</li><li>第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</li></ul><p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 一个或多个可迭代对象（如：序列）</p><p><strong>返回值：</strong><br>Python 3.x 返回迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x*x</span><br><span class="line">ret = map(func, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">print(list(ret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="reduce-函数语法"><a href="#reduce-函数语法" class="headerlink" title="reduce()函数语法"></a>reduce()函数语法</h5><p><strong>reduce(function, iterable[, initializer])</strong><br><strong>功能：</strong></p><ul><li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。<br>其效果类似：reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</li><li>reduce() 函数会对参数序列中元素进行累积。</li><li>函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。</li></ul><p><strong>参数：</strong><br>function – 函数，有两个参数<br>iterable – 可迭代对象<br>initializer – 可选，初始参数</p><p><strong>返回值：</strong><br>返回函数计算结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"> </span><br><span class="line">r = reduce(add, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 运行结果：</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="filter-函数："><a href="#filter-函数：" class="headerlink" title="filter()函数："></a>filter()函数：</h5><p><strong>filter(function, iterable)</strong><br><strong>功能</strong></p><ul><li>该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判断，然后返回 True 或 False，最后将返回 True 的元素放到新迭代器对象中</li><li>filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</li></ul><p><strong>参数：</strong><br>function – 判断函数<br>iterable – 可迭代对象（如：序列）</p><p><strong>返回值：</strong><br>返回一个迭代器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">tmplist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line">newlist = list(tmplist)</span><br><span class="line">print(newlist)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果：</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted()函数"></a>sorted()函数</h5><p><strong>sorted(iterable, key=abs, reverse=False)</strong><br><strong>功能:</strong></p><ul><li>对所有可迭代的对象进行排序操作</li></ul><p><strong>参数:</strong><br>iterable – 可迭代对象。<br>key – key指定的函数将作用于可迭代对象上的每一个元素，并根据key函数返回的结果进行排序<br>reverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）</p><p><strong>返回值:</strong><br>返回重新排序的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># demo:</span></span><br><span class="line"></span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>]))</span><br><span class="line">运行结果：[<span class="number">-21</span>, <span class="number">-12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br><span class="line">print(sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs))</span><br><span class="line"></span><br><span class="line"><span class="comment">#abs 匿名函数</span></span><br><span class="line">运行结果：[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="返回函数："><a href="#返回函数：" class="headerlink" title="返回函数："></a>返回函数：</h5><p><strong>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sum</span>():</span></span><br><span class="line">        ax = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        <span class="keyword">return</span> ax</span><br><span class="line">    <span class="keyword">return</span> sum        <span class="comment">#将定义的函数sum()作为结果值返回</span></span><br><span class="line"> </span><br><span class="line">f = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.3 filter()函数可以对序列做过滤处理</strong></p><p>利用 filter、lambda表达式 获取l1中元素小于33的所有元素 l1 = [11, 22, 33, 44, 55]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a = filter(<span class="keyword">lambda</span> x: x&lt;<span class="number">33</span>, l1)</span><br><span class="line">print(list(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.4 Map是对序列根据设定条件进行操作后返回他设置的是操作方法</strong><br><code>利用map，lambda表达式将所有偶数元素加100</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l1= [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">ret = map(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span> <span class="keyword">else</span> x + <span class="number">100</span>,l1)</span><br><span class="line">print(list(ret))</span><br><span class="line"><span class="comment"># 运行结果： [11, 122, 33, 144, 55]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.5 reduce函数</strong></p><p>使用reduce进行求和运算</p><ol><li>reduce()函数即为化简函数，它的执行过程为：每一次迭代，都将上一次的迭代结果与下一个元素一同传入二元func函数中去执行。</li><li>在reduce()函数中，init是可选的，如果指定，则作为第一次迭代的第一个元素使用，如果没有指定，就取seq中的第一个元素。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line"> <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">print(reduce(f, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]))  <span class="comment"># 25</span></span><br><span class="line"><span class="comment"># 1、先计算头两个元素：f(1, 3)，结果为4；</span></span><br><span class="line"><span class="comment"># 2、再把结果和第3个元素计算：f(4, 5)，结果为9；</span></span><br><span class="line"><span class="comment"># 3、再把结果和第4个元素计算：f(9, 7)，结果为16；</span></span><br><span class="line"><span class="comment"># 4、再把结果和第5个元素计算：f(16, 9)，结果为25；</span></span><br><span class="line"><span class="comment"># 5、由于没有更多的元素了，计算结束，返回结果25。</span></span><br><span class="line"></span><br><span class="line">print( reduce(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])  )  <span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.6 sorted函数</strong></p><p>sorted对字典排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;k3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;k2&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># d.items() = [(&#x27;k1&#x27;, 1), (&#x27;k3&#x27;, 3), (&#x27;k2&#x27;, 2)]</span></span><br><span class="line">a = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">print(a)            <span class="comment"># [(&#x27;k1&#x27;, 1), (&#x27;k2&#x27;, 2), (&#x27;k3&#x27;, 3)]</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>subprocess是Python 2.4中新增的一个模块，它允许你生成新的进程，连接到它们的 input/output/error 管道，并获取它们的返回（状态）码。这个模块的目的在于替换几个旧的模块和方法，如：</p><ul><li>os.system</li><li>os.spawn*</li></ul><h5 id="subprocess模块中的常用函数"><a href="#subprocess模块中的常用函数" class="headerlink" title="subprocess模块中的常用函数"></a>subprocess模块中的常用函数</h5><ul><li><strong>subprocess.run()</strong><br>Python 3.5中新增的函数。执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。</li><li><strong>subprocess.call()</strong><br>执行指定的命令，返回命令执行状态，其功能类似于os.system(cmd)。</li><li><strong>subprocess.check_call()</strong><br>Python 2.5中新增的函数。 执行指定的命令，如果执行成功则返回状态码，否则抛出异常。其功能等价于subprocess.run(…, check=True)。</li><li><strong>subprocess.check_output()</strong><br>Python 2.7中新增的的函数。执行指定的命令，如果执行状态码为0则返回命令执行结果，否则抛出异常。</li><li><strong>subprocess.getoutput(cmd)</strong><br>接收字符串格式的命令，执行命令并返回执行结果，其功能类似于<br>os.popen(cmd).read()和commands.getoutput(cmd)。</li><li><strong>subprocess.getstatusoutput(cmd)</strong><br>执行cmd命令，返回一个元组(命令执行状态, 命令执行结果输出)，其功能类似于commands.getstatusoutput()。</li></ul><h3 id="paramiko模块"><a href="#paramiko模块" class="headerlink" title="paramiko模块"></a>paramiko模块</h3><p>paramiko是一个用于做远程控制的模块，使用该模块可以对远程服务器进行命令或文件操作,paramiko是用python语言写的一个模块，遵循SSH2协议，支持以加密和认证的方式，进行远程服务器的连接。</p><p>由于使用的是python这样的能够跨平台运行的语言，所以所有python支持的平台，如Linux, Solaris, BSD, MacOS X, Windows等，paramiko都可以支持，因此，如果需要使用SSH从一个平台连接到另外一个平台，进行一系列的操作时，paramiko是最佳工具之一。</p><h4 id="python２和python３的区别："><a href="#python２和python３的区别：" class="headerlink" title="python２和python３的区别："></a>python２和python３的区别：</h4><ol><li>python2 解释器默认编码：ascii　　python3 解释器默认编码：utf-8</li><li>range在Python2中返回列表，而在Python3中返回range可迭代对象。</li><li>在Python2中有两个不等运算符!=和&lt;&gt;，在Python3中去掉了&lt;&gt;，只有!=符号表示不等</li><li>在Python2中long是比int取值范围更大的整数，Python3中取消了long类型，int的取值范围扩大到之前的long类型范围。</li><li>python2 的代码混乱，重复较多，冗余。python3源码规范、清晰、简单优美。</li><li>python3x：unicode 默认是4个字节表示一个字符、python2x :unicode 默认2个字节表示一个字符</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python知识点&quot;&gt;&lt;a href=&quot;#Python知识点&quot; class=&quot;headerlink&quot; title=&quot;Python知识点&quot;&gt;&lt;/a&gt;Python知识点&lt;/h2&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/python/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django + uWSGI + Nginx 的生产环境部署，及WSGI &amp; uwsgi &amp; uWSGI 的作用</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/29/Django%20+%20uWSGI%20+%20Nginx%20%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%8F%8AWSGI%20&amp;%20uwsgi%20&amp;%20uWSGI%20%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/29/Django%20+%20uWSGI%20+%20Nginx%20%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%EF%BC%8C%E5%8F%8AWSGI%20&amp;%20uwsgi%20&amp;%20uWSGI%20%E7%9A%84%E4%BD%9C%E7%94%A8/</id>
    <published>2020-08-28T16:18:29.000Z</published>
    <updated>2020-09-13T12:02:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>uWSGI的 <a href="https://blog.csdn.net/weixin_44685869/article/details/103951161">介绍 看这里</a></p><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><ol><li>Nginx是一个Web服务器,其中的HTTP服务器功能和uWSGI功能很类似</li><li>但是Nginx还可以用作更多用途，比如最常用的反向代理、负载均衡、拦截攻击等，而且性能极高</li></ol><h4 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h4><ol><li>Django是一个Web框架，框架的作用在于处理request和 reponse，其他的不是框架所关心的内容。</li><li>所以如何部署Django不是Django所需要关心的。</li></ol><p><img src="https://img-blog.csdnimg.cn/20200304220900982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这里举个小例子：</span><br><span class="line">我们的浏览器是 出生在海外的华侨，通过HTTP(飞机) 从 Nginx(日本) 回到  (Python 中国)</span><br><span class="line">下飞机 到了之后发现语言不通，急忙的找到了我。</span><br><span class="line">他说日语(uwsgi)“こんにちは“</span><br><span class="line">我会日语啊 我把这句话 转换成了 汉语(uWSGI)给 别人听</span><br><span class="line">这样就可以 在 中国(Python) 让日本人(浏览器) 生活了。</span><br><span class="line">但是 博主是东北人 光会转义 日语-&gt;普通话 还不行 还要和我的家人们说东北话(WSGI)</span><br><span class="line">此时 就已经非常完美的解决了语言不通的问题了。</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure><ul><li>请求处理整体流程</li></ul><ol><li>nginx接收到浏览器发送过来的http请求，将包进行解析，分析url</li><li>静态文件请求：就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件</li><li>动态接口请求：那么nginx就将请求转发给uWSGI，最后到达django处理</li></ol><ul><li>各模块作用</li></ul><ol><li><p>nginx：是对外的服务器，外部浏览器通过url访问nginx，nginx主要处理静态请求</p></li><li><p>uWSGI：是对内的服务器，主要用来处理动态请求</p></li><li><p>uwsgi：是一种web协议，接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi</p></li><li><p>wsgi：是python专用的web协议，根据请求调用应用程序（django）的某个文件，某个文件的某个函数</p></li><li><p>django：是真正干活的，查询数据等资源，把处理的结果再次返回给WSGI， WSGI 将返回值进行打包，打包成uwsgi能够接收的格式</p></li><li><p>uwsgi接收wsgi发送的请求，并转发给nginx,nginx最终将返回值返回给浏览器</p></li></ol><h3 id="Django-uwsgi方案"><a href="#Django-uwsgi方案" class="headerlink" title="Django + uwsgi方案"></a>Django + uwsgi方案</h3><ol><li>没有nginx而只有uwsgi的服务器，则是Internet请求直接由uwsgi处理，并反馈到web项目中。</li><li>nginx可以实现安全过滤，防DDOS等保护安全的操作，并且如果配置了多台服务器，nginx可以保证服务器的负载相对均衡。</li><li>而uwsgi则是一个web服务器，实现了WSGI协议(Web Server Gateway Interface)，http协议等，它可以接收和处理请求，发出响应等。<br>所以只用uwsgi也是可以的。</li></ol><h3 id="nginx和uWSGI特点"><a href="#nginx和uWSGI特点" class="headerlink" title="nginx和uWSGI特点"></a>nginx和uWSGI特点</h3><ul><li>nginx的作用</li></ul><ol><li>反向代理，可以拦截一些web攻击，保护后端的web服务器</li><li>负载均衡，根据轮询算法，分配请求到多节点web服务器</li><li>缓存静态资源，加快访问速度，释放web服务器的内存占用，专项专用</li></ol><ul><li>uWSGI的适用</li></ul><ol><li><p>单节点服务器的简易部署</p></li><li><p>轻量级，好部署</p></li></ol><p>Django + Uwsgi + Nginx 的生产环境部署</p><h4 id="在centos-7中安装python3环境"><a href="#在centos-7中安装python3环境" class="headerlink" title="在centos 7中安装python3环境"></a>在centos 7中安装python3环境</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="comment"># 1、yum更新yum源</span></span><br><span class="line">yum update</span><br><span class="line"><span class="comment"># 2、安装Python 3.7所需的依赖否则安装后没有pip3包</span></span><br><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel libffi-devel gcc make</span><br><span class="line"><span class="comment"># 3、在官网下载所需版本，这里用的是3.7.0版本</span></span><br><span class="line">wget https://www.python.org/ftp/<span class="number">3.7</span><span class="number">.0</span>/Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line">　　<span class="number">2</span>、安装Python</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、解压</span></span><br><span class="line">tar -xvf Python<span class="number">-3.7</span><span class="number">.0</span>.tgz</span><br><span class="line"></span><br><span class="line"><span class="comment">#2、配置编译</span></span><br><span class="line">cd Python<span class="number">-3.7</span><span class="number">.0</span></span><br><span class="line">./configure --prefix=/usr/local/python3  <span class="comment"># 配置编译的的路径（这里--prefix是指定编译安装的文件夹）</span></span><br><span class="line">./configure --enable-optimizations  <span class="comment"># 执行该代码后，会编译安装到 /usr/local/bin/ 下，且不用添加软连接或环境变量</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3  <span class="comment"># 添加软连接</span></span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3</span><br><span class="line"></span><br><span class="line"><span class="comment">#3、将/usr/local/python3/bin加入PATH</span></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># vim /etc/profile</span></span><br><span class="line"><span class="comment">#然后在文件末尾添加</span></span><br><span class="line">export PATH=$PATH:/usr/local/python3/bin</span><br><span class="line"></span><br><span class="line">[root@linux-node1 testProj]<span class="comment"># source /etc/profile # 修改完后，还需要让这个环境变量在配置信息中生效，执行命令</span></span><br></pre></td></tr></table></figure><h4 id="初始化一个django项目"><a href="#初始化一个django项目" class="headerlink" title="初始化一个django项目"></a>初始化一个django项目</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化一个django项目</span></span><br><span class="line"></span><br><span class="line">[root@linux-node1 /] pip3 install django==<span class="number">2.0</span><span class="number">.4</span></span><br><span class="line">[root@linux-node1 /] mkdir /code/</span><br><span class="line">[root@linux-node1 /] cd /code/</span><br><span class="line">[root@linux-node1 testProj] django-admin startproject mmcsite</span><br><span class="line">[root@linux-node1 testProj] cd /code/mmcsite</span><br><span class="line">[root@linux-node1 testProj] python3 manage.py runserver <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8000</span></span><br><span class="line"></span><br><span class="line">页面中访问：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span>:<span class="number">8000</span>/</span><br></pre></td></tr></table></figure><h4 id="安装uwsgi-并使用uWSGI启动这个服务"><a href="#安装uwsgi-并使用uWSGI启动这个服务" class="headerlink" title="安装uwsgi 并使用uWSGI启动这个服务"></a>安装uwsgi 并使用uWSGI启动这个服务</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;1. 安装uwsgi&#x27;&#x27;&#x27;</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># pip3 install uwsgi</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># ln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;2. 配置uwsgi.ini启动文件&#x27;&#x27;&#x27;</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># vim uwsgi.ini</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span></span><br><span class="line">chdir = /code/mmcsite</span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py</span><br><span class="line">processes = <span class="number">5</span></span><br><span class="line">threads = <span class="number">30</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log</span><br><span class="line">module=mmcsite.wsgi</span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid</span><br><span class="line">chmod-socket=<span class="number">666</span></span><br><span class="line">enable-threads = true</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;3. 使用uwsgi启动django：一定要在这个项目目录中&#x27;&#x27;&#x27;</span></span><br><span class="line">[root@linux-node1 /]<span class="comment"># uwsgi --http 192.168.56.11:80 --file mmcsite/wsgi.py --static-map=/static=static</span></span><br><span class="line">访问项目：http://<span class="number">192.168</span><span class="number">.56</span><span class="number">.11</span></span><br><span class="line"></span><br><span class="line">[root@linux-node2 demo2]<span class="comment"># vim /code/mmcsite/uwsgi.ini  # uwsgi.ini文件</span></span><br><span class="line">[uwsgi]</span><br><span class="line">socket = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3031</span>                  <span class="comment"># 指定socket监听的地址和端口</span></span><br><span class="line">chdir = /code/mmcsite                  <span class="comment"># 项目路径 </span></span><br><span class="line">wsgi-file = /code/mmcsite/wsgi.py      <span class="comment"># django的wsgi文件路径</span></span><br><span class="line">processes = <span class="number">5</span>                          <span class="comment"># 启动五个进程</span></span><br><span class="line">threads = <span class="number">30</span>                           <span class="comment"># 每个进程启动30个线程</span></span><br><span class="line">master = true</span><br><span class="line">daemonize = /code/mmcsite/uwsgi.log    <span class="comment"># 日志存放路径</span></span><br><span class="line">module=mmcsite.wsgi                    <span class="comment"># 使用mmcsite.wsgi模块</span></span><br><span class="line">pidfile = /code/mmcsite/uwsgi.pid      <span class="comment"># uwsgi启动进程id存放路径</span></span><br><span class="line">chmod-socket=<span class="number">666</span>                       <span class="comment"># socket权限</span></span><br><span class="line">enable-threads = true                  <span class="comment"># 允许用内嵌的语言启动线程，这将允许你在app程序中产生一个子线程</span></span><br></pre></td></tr></table></figure><h4 id="安装配置nginx"><a href="#安装配置nginx" class="headerlink" title="安装配置nginx"></a>安装配置nginx</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;1. 配置nginx YUM源&#x27;&#x27;&#x27;</span></span><br><span class="line">[root@linux-node1 /] vim /etc/yum.repos.d/nginx.repo</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p>[nginx]<br>name=nginx repo</p><h1 id="下面这行centos根据你自己的操作系统修改比如：OS-rehel"><a href="#下面这行centos根据你自己的操作系统修改比如：OS-rehel" class="headerlink" title="下面这行centos根据你自己的操作系统修改比如：OS/rehel"></a>下面这行centos根据你自己的操作系统修改比如：OS/rehel</h1><h1 id="6是你Linux系统的版本，可以通过URL查看路径是否正确"><a href="#6是你Linux系统的版本，可以通过URL查看路径是否正确" class="headerlink" title="6是你Linux系统的版本，可以通过URL查看路径是否正确"></a>6是你Linux系统的版本，可以通过URL查看路径是否正确</h1><p>baseurl=<a href="http://nginx.org/packages/centos/7/$basearch/">http://nginx.org/packages/centos/7/$basearch/</a><br>gpgcheck=0<br>enabled=1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#39;&#39;&#39;2. 安装nginx&#39;&#39;&#39;</span><br><span class="line">[root@linux-node1 &#x2F;] yum -y install nginx</span><br><span class="line"></span><br><span class="line">安装nginx</span><br><span class="line">1234</span><br><span class="line">[root@linux-node1 &#x2F;]# vim &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;django.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen       8888;</span><br><span class="line">    server_name  192.168.56.11;</span><br><span class="line">    client_max_body_size 5M;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_buffers 32 4K;#压缩在内存中缓冲32块 每块4K</span><br><span class="line">    gzip_comp_level 6 ;#压缩级别 推荐6</span><br><span class="line">    gzip_min_length 4000;#开始压缩的最小长度4bit</span><br><span class="line">        gzip_types text&#x2F;plain application&#x2F;json application&#x2F;javascript application&#x2F;x-javascript application&#x2F;css application&#x2F;xml application&#x2F;xml+rss text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png image&#x2F;x-ms-bmp;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">              include uwsgi_params;</span><br><span class="line">              uwsgi_pass 127.0.0.1:3031;</span><br><span class="line">              uwsgi_ignore_client_abort on;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 404 &#x2F;404.html;</span><br><span class="line">            location &#x3D; &#x2F;40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 &#x2F;50x.html;</span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置nginx</span><br></pre></td></tr></table></figure><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@linux-node1 demo2]<span class="comment"># systemctl restart nginx   # 开启nginx</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --ini uwsgi.ini     # 启动uwsgi的django项目</span></span><br><span class="line"><span class="comment"># http://192.168.56.11:8888/ 访问项目</span></span><br><span class="line">[root@linux-node1 demo2]<span class="comment"># uwsgi --stop uwsgi.pid    # 关闭uwsgi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;uWSGI的 &lt;a href=&quot;https://blog.csdn.net/weixin_44685869/article/details/103951161&quot;&gt;介绍 看这里&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;he</summary>
      
    
    
    
    <category term="docker" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/docker/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 的基本常用命令</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/27/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/27/Docker%20%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-08-26T18:18:06.000Z</published>
    <updated>2020-09-13T12:00:12.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>docker 镜像管理常用命令</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker help</td><td>查看docker帮助</td></tr><tr><td>docker image –help</td><td>查看 docker中 镜像相关帮助</td></tr><tr><td>docker image ls</td><td>查看当前所有镜像</td></tr><tr><td>docker image inspect nginx</td><td>查看指定镜像（nginx镜像）详细信息</td></tr><tr><td>docker pull nginx:1.14</td><td>下载指定版本镜像 nginx</td></tr><tr><td>docker image rm nginx:1.14</td><td>删除nginx 1.14版本</td></tr><tr><td>docker image save nginx &gt; nginx.tar</td><td>导出niginx镜像</td></tr></tbody></table><p>docker创建容器常用命令</p><p>docker run 常用参数</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>-d:</td><td>后台运行容器，并返回容器ID；</td></tr><tr><td>-i:</td><td>以交互模式运行容器，通常与 -t 同时使用；</td></tr><tr><td>-t:</td><td>为容器重新分配一个伪输入终端，通常与 -i 同时使用；</td></tr><tr><td>-P:</td><td>随机端口映射，容器内部端口随机映射到主机的高端口</td></tr><tr><td>-p:</td><td>指定端口映射，格式为：主机(宿主)端口:容器端口</td></tr><tr><td>–name=“nginx-lb”:</td><td>为容器指定一个名称；</td></tr><tr><td>–dns 8.8.8.8:</td><td>指定容器使用的DNS服务器，默认和宿主一致；</td></tr></tbody></table><p>docker run 其他参数</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>–dns-search example.com:</td><td>指定容器DNS搜索域名，默认和宿主一致；</td></tr><tr><td>-h “mars”:</td><td>指定容器的hostname；</td></tr><tr><td>-e username=“ritchie”:</td><td>设置环境变量；</td></tr><tr><td>–env-file=[]:</td><td>从指定文件读入环境变量；</td></tr><tr><td>–cpuset=“0-2” or –cpuset=“0,1,2”:</td><td>绑定容器到指定CPU运行；</td></tr><tr><td>-m :</td><td>设置容器使用内存最大值；</td></tr><tr><td>–net=“bridge”:</td><td>指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</td></tr><tr><td>–link=[]:</td><td>添加链接到另一个容器；</td></tr><tr><td>–expose=[]:</td><td>开放一个端口或一组端口；</td></tr><tr><td>–volume , -v:</td><td>绑定一个卷</td></tr><tr><td>-a stdin:</td><td>指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</td></tr><tr><td>docker run</td><td>其他参数</td></tr></tbody></table><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker run –help</td><td>查看创建容器帮助</td></tr><tr><td>docker run -it centos</td><td>创建centos镜像并进入终端</td></tr><tr><td>docker run -d nginx</td><td>后台启动nginx容器</td></tr><tr><td>docker stop 6bb09dce461f</td><td>关闭一个容器</td></tr><tr><td>docker ps -l</td><td>查看最近运行的容器</td></tr><tr><td>docker run -itd centos</td><td>启用一个伪终端守护centos容器</td></tr><tr><td>docker container run -d –name web3 -e test=123456 -p 8800:80 -h webhostname –restart always nginx</td><td></td></tr><tr><td>-d</td><td>后台启动nginx容器</td></tr><tr><td>–name web3</td><td>自定义容器名字(默认会是一段随机字符串)</td></tr><tr><td>-e test=123456</td><td>启动容器添加变量 test=123456 (echo $test)</td></tr><tr><td>-p 8800:80</td><td>宿主机的8800端口映射到docker容器的80端口中</td></tr><tr><td>-h webhostname</td><td>docker容器主机名 (a300f394af88)</td></tr><tr><td>–restart always</td><td>宿主机重启自动拉起这个docker容器</td></tr><tr><td>nginx</td><td>使用这个nginx镜像启动容器</td></tr><tr><td>docker logs web</td><td>查看上面启动的web容器的日志</td></tr><tr><td>docker exec -it web bash</td><td>进入容器web</td></tr></tbody></table><h4 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h4><ol><li><p>内存限额： 允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer<br>docker run -d –name nginx03 –memory=“500m” –memory-swap=“600m” –oom-kill-disable nginx</p></li><li><p>CPU限额：<br>docker run -d –name nginx04 –cpus=“1.5” nginx # 允许容器最多使用一个半的CPU<br>docker run -d –name nginx05 –cpus=”.5” nginx # 允许容器最多使用50%的CPU</p></li></ol><p>docker 管理 容器常用命令</p><table><thead><tr><th>命令</th><th>示意</th></tr></thead><tbody><tr><td>docker ps</td><td>仅列出当前运行的容器</td></tr><tr><td>docker ps -l</td><td>列出最新创建得容器</td></tr><tr><td>docker ps -a</td><td>列出素有容器(包括 未运行的)</td></tr><tr><td>docker inspect web4</td><td>列出指定容器的详细信息</td></tr></tbody></table><p>持久化容器</p><table><thead><tr><th>docker exec -it web4 bash</th><th>进入容器web4中</th></tr></thead><tbody><tr><td>touch 1.txt 2.txt</td><td>对容器进行修改</td></tr><tr><td>docker commit web4 nginx:web4</td><td>将修改后的web4容器提交为一个新镜像 nginx:web4</td></tr><tr><td>docker images</td><td>可以看到 多了一个 TAG标记为 web4 的镜像</td></tr><tr><td>docker run -d –name web4-1 nginx:web4</td><td>使用刚刚提交的镜像web4创建一个容器web4-1</td></tr><tr><td>docker exec -it web4-1 bash</td><td>进入web4-1的bash环境</td></tr></tbody></table><p>从宿主机复制文件到docker容器</p><table><thead><tr><th>docker cp nginx.tar web4-1:/home</th><th>将宿主机nginx.tar文件拷贝到容器web4-1的/home目录中</th></tr></thead><tbody><tr><td>docker exec -it web4-1 ls /home</td><td>在容器web4-1中执行 “ls /home” 命令</td></tr></tbody></table><p>容器常用查询命令</p><table><thead><tr><th>docker logs web4-1</th><th>查看web4-1中控制台日志</th></tr></thead><tbody><tr><td>docker port 55f870061ed9</td><td>查看指定容器端口映射</td></tr><tr><td>docker top 00f7ddc96622</td><td>查看容器中有哪些进程</td></tr><tr><td>docker stats 00f7ddc96622</td><td>查看容器资源使用情况</td></tr></tbody></table><p>启动、停止、删除 容器</p><table><thead><tr><th>docker ps -a</th><th>列出素有容器(包括 未运行的)</th></tr></thead><tbody><tr><td>docker start web</td><td>启动容器web</td></tr><tr><td>docker stop web</td><td>停止容器web</td></tr><tr><td>docker rm web</td><td>删除容器</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200304173914455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM</summary>
      
    
    
    
    <category term="docker" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/docker/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 镜像 &amp; 容器和镜像的联系 读写层</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/25/Docker%20%E9%95%9C%E5%83%8F%20&amp;%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E8%81%94%E7%B3%BB%20%E8%AF%BB%E5%86%99%E5%B1%82/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/25/Docker%20%E9%95%9C%E5%83%8F%20&amp;%20%E5%AE%B9%E5%99%A8%E5%92%8C%E9%95%9C%E5%83%8F%E7%9A%84%E8%81%94%E7%B3%BB%20%E8%AF%BB%E5%86%99%E5%B1%82/</id>
    <published>2020-08-24T17:24:07.000Z</published>
    <updated>2020-09-13T11:59:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>Docker 镜像</p><h4 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h4><ul><li>一个分层存储的文件</li><li>一个软件的环境</li><li>一个镜像可以创建N个容器</li><li>一个标准化的交付</li><li>一个不包含Linux内核而又精简的Linux操作系统</li></ul><p>人性化一点 ↓</p><ol><li>docker镜像不包含Linux内核而又精简的Linux操作系统</li><li>docker镜像是一个分层存储的文件，一个镜像可以创建N个容器</li><li>可以这么理解，docker 镜像是 docker 容器的静态视角，docker 容器是 docker 镜像的运行状态。</li><li>容器只是对docker镜像的引用，如果docker镜像删除，此镜像创建的容器也都失效</li></ol><p>镜像不是一个单一的文件，而是有多层结构。我们可以通过 docker history &lt;ID/NAME&gt; 查看镜像中各层内容及大小，每层对应着DOckerfile 中的一条命令。Docker镜像默认存储在 /var/lib/docker/<storage-driver>中。</p><p>是在驱动中 所以说目录下的文件都有可能 最佳推荐：<code>overlay2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker info  查看</span><br><span class="line"></span><br><span class="line">Storage Driver: overlay2</span><br></pre></td></tr></table></figure><h4 id="镜像从哪里来的？"><a href="#镜像从哪里来的？" class="headerlink" title="镜像从哪里来的？"></a>镜像从哪里来的？</h4><p>Docker Hub 是由 Docker公司负责维护公共注册中心，包含大量的容器镜像，Docker工具默认从这个公共镜像库下载镜像<br>地址: <a href="https://hub.docker.com/explore">https://hub.docker.com/explore</a></p><p>我们看一下 镜像默认源 docker info<br><img src="https://img-blog.csdnimg.cn/20200304134108864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>拿到了地址 我们 ping 一下<br><img src="https://img-blog.csdnimg.cn/20200304134254433.png" alt="在这里插入图片描述"><br>amazonaws:亚马逊服务器<br>也可以浏览器 访问一下端口<br><img src="https://img-blog.csdnimg.cn/20200304134401377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h5><p><a href="https://www.daocloud/mirror">https://www.daocloud/mirror</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sSL https://get.daocloud.io/daotools/set_mirror.sh |sh -s http://f1361db2.m.daocloud.io</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>我们可以通过 命令查看 镜像加速的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;http://f1361db2.m.daocloud.io&quot;</span>]&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>配置完 重启docker</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>Docker 镜像和容器的联系、区别</p><p><img src="https://img-blog.csdnimg.cn/20200304142824563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中可以看出</p><ul><li>容器其实是在镜像的最上面加了一层读写层，在运行容器里文件改动时，会先从镜像里要写的文件复制到容器自己的文件系统中（读写层）。</li><li>如果容器删除了，最上面的读写层也就删除了，改动也就丢失了。</li><li>所以无论多少个容器共享一个镜像，所做的写操作都是从镜像的文件系统中复制（引用）过来的操作的，并不会修改镜像的源文件，这种方式提高磁盘利用率。</li><li>若想持久化这些改动，可以通过 docker commit 将容器保存成一个新的镜像。</li></ul><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 nginx容器</span></span><br><span class="line">docker run -itd nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200304143630125.png" alt="在这里插入图片描述"><br>我们访问这个 容器的ID</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入镜像</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">5</span>ceaf43bd114 bash</span><br><span class="line"></span><br><span class="line">ls</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200304143824221.png" alt="在这里插入图片描述"><br>可以看出这个是和 镜像一样的。由此证出，docker 容器只是对 镜像进行了引用</p><p><code>***</code><br>读写层的意思就是说，</p><ul><li><p>镜像会将所有数据拷贝到读写层，然后进行操作</p></li><li><p>你在容器中 进行写入东西的时候 不管你写入多少，是对 引用的镜像是无反应的。<br><code>***</code></p></li></ul><h4 id="docker-容器和镜像的具体区别"><a href="#docker-容器和镜像的具体区别" class="headerlink" title="docker 容器和镜像的具体区别"></a>docker 容器和镜像的具体区别</h4><ol><li>当由 ubuntu:14.04 镜像启动容器时，ubuntu:14.04 镜像的镜像层内容将作为容器的 rootfs；</li><li>而 ubuntu:14.04 镜像的 json 文件，会由 docker daemon 解析，并提取出其中的容器执行入口 CMD 信息，<br>以及容器进程的环境变量 ENV 信息，最终初始化容器进程。</li><li>当然，容器进程的执行入口来源于镜像提供的 rootfs。</li></ol><p><img src="https://img-blog.csdnimg.cn/2020030414582499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h4><ol><li>rootfs 是 docker 容器在启动时内部进程可见的文件系统，即 docker 容器的根目录。</li><li>rootfs 通常包含一个操作系统运行所需的文件系统，例如可能包含典型的类 Unix 操作系统中的目录系统，<br>如 /dev、/proc、/bin、/etc、/lib、/usr、/tmp 及运行 docker 容器所需的配置文件、工具等。</li><li>在传统的 Linux 操作系统内核启动时，首先挂载一个只读的 rootfs，当系统检测其完整性之后，再将其切换为读写模式。</li><li>而在 docker 架构中，当 docker daemon 为 docker 容器挂载 rootfs 时，沿用了 Linux 内核启动时的做法，即将 rootfs 设为只读模式。</li><li>在挂载完毕之后，利用联合挂载(union mount)技术在已有的只读 rootfs 上再挂载一个读写层。</li><li>这样，可读写的层处于 docker 容器文件系统的最顶层，其下可能联合挂载了多个只读的层，</li><li>只有在 docker 容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层中的旧版本文件。</li></ol><h4 id="查看容器中镜像内容"><a href="#查看容器中镜像内容" class="headerlink" title="查看容器中镜像内容"></a>查看容器中镜像内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建web1 容器</span></span><br><span class="line">docker run -itd --name=web1 -p <span class="number">192.168</span><span class="number">.56</span><span class="number">.14</span>:<span class="number">81</span>:<span class="number">80</span> nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器内容</span></span><br><span class="line">docker inspect web1 | more</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以下就是容器的详细信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只摘选局部</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;GraphDriver&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13-init/diff:/var/lib/docker/overlay2/09fa1314e484781dfc1fb25a6cf5df2502fe35dea9025a373a3cb0202732ccce/diff:/var/lib/docker/overlay2/162ec5c9be56e5d718011c09ed087eda04b755e1a68bd1953c60f175e6635e68/diff:/var/lib/docker/overlay2/7c1b27ff59a397ae7d6bd106db579e90476f57bb1ecef9fcb1a6f1ad5ce43b7c/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/merged&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/diff&quot;</span>,</span><br><span class="line">                <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/51692869029f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13/work&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;NetworkSettings&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Ports&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;80/tcp&quot;</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">&quot;HostIp&quot;</span>: <span class="string">&quot;192.168.56.14&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;HostPort&quot;</span>: <span class="string">&quot;81&quot;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:ac:11:00:02&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Networks&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;bridge&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPAddress&quot;</span>: <span class="string">&quot;172.17.0.2&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;IPPrefixLen&quot;</span>: <span class="number">16</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>可以看到 读写层（自己 吧下面得数字 Ctrl + F 看吧）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@linux-node4 diff] cd /var/lib/docker/overlay2/<span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13</span><br><span class="line"></span><br><span class="line">[root@linux-node4 <span class="number">51692869029</span>f819494bb402dc70aa2869b8d1848c3b65c549a010a260e44cc13]<span class="comment"># ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写层的文件 </span></span><br><span class="line">diff  link  lower  merged  work</span><br></pre></td></tr></table></figure><p>work 是工作的地方<br>diff 是镜像和读写层的差异<br>merged 是镜像引用下来的 读写层</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200304131346637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM</summary>
      
    
    
    
    <category term="docker" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/docker/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Nginx 配置文件</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/23/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/23/Nginx%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</id>
    <published>2020-08-23T15:11:01.000Z</published>
    <updated>2020-09-13T11:57:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>Nginx 配置</strong></p><h5 id="nginx配置文件注释"><a href="#nginx配置文件注释" class="headerlink" title="nginx配置文件注释"></a>nginx配置文件注释</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">运行用户</span></span><br><span class="line">user nobody;</span><br><span class="line"><span class="meta">#</span><span class="bash">启动进程,通常设置成和cpu的数量相等</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">全局错误日志及PID文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">pid        logs/nginx.pid;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">工作模式及连接数上限</span></span><br><span class="line">events &#123;</span><br><span class="line">    #epoll是多路复用IO(I/O Multiplexing)中的一种方式,</span><br><span class="line">    #仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    use   epoll; </span><br><span class="line"> </span><br><span class="line">    #单个后台worker process进程的最大并发链接数    </span><br><span class="line">    worker_connections  1024;</span><br><span class="line"> </span><br><span class="line">    # 并发总数是 worker_processes 和 worker_connections 的乘积</span><br><span class="line">    # 即 max_clients = worker_processes * worker_connections</span><br><span class="line">    # 在设置了反向代理的情况下，max_clients = worker_processes * worker_connections / 4  为什么</span><br><span class="line">    # 为什么上面反向代理要除以4，应该说是一个经验值</span><br><span class="line">    # 根据以上条件，正常情况下的Nginx Server可以应付的最大连接数为：4 * 8000 = 32000</span><br><span class="line">    # worker_connections 值的设置跟物理内存大小有关</span><br><span class="line">    # 因为并发受IO约束，max_clients的值须小于系统可以打开的最大文件数</span><br><span class="line">    # 而系统可以打开的最大文件数和内存大小成正比，一般1GB内存的机器上可以打开的文件数大约是10万左右</span><br><span class="line">    # 我们来看看360M内存的VPS可以打开的文件句柄数是多少：</span><br><span class="line">    # $ cat /proc/sys/fs/file-max</span><br><span class="line">    # 输出 34336</span><br><span class="line">    # 32000 &lt; 34336，即并发连接总数小于系统可以打开的文件句柄总数，这样就在操作系统可以承受的范围之内</span><br><span class="line">    # 所以，worker_connections 的值需根据 worker_processes 进程数目和系统可以打开的最大文件总数进行适当地进行设置</span><br><span class="line">    # 使得并发总数小于操作系统可以打开的最大文件数目</span><br><span class="line">    # 其实质也就是根据主机的物理CPU和内存进行配置</span><br><span class="line">    # 当然，理论上的并发总数可能会和实际有所偏差，因为主机还有其他的工作进程需要消耗系统资源。</span><br><span class="line">    # ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include    mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"> </span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line"> </span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span><br><span class="line">    #对于普通应用，必须设为 on,</span><br><span class="line">    #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，</span><br><span class="line">    #以平衡磁盘与网络I/O处理速度，降低系统的uptime.</span><br><span class="line">    sendfile     on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"> </span><br><span class="line">    #连接超时时间</span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"> </span><br><span class="line">    #开启gzip压缩</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6].&quot;;</span><br><span class="line"> </span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    client_header_buffer_size    128k;</span><br><span class="line">    large_client_header_buffers  4 128k;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #设定虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        #侦听80端口</span><br><span class="line">        listen    80;</span><br><span class="line">        #定义使用 www.nginx.cn访问</span><br><span class="line">        server_name  www.nginx.cn;</span><br><span class="line"> </span><br><span class="line">        #定义服务器的默认网站根目录位置</span><br><span class="line">        root html;</span><br><span class="line"> </span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs/nginx.access.log  main;</span><br><span class="line"> </span><br><span class="line">        #默认请求</span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            #定义首页索引文件的名称</span><br><span class="line">            index index.php index.html index.htm;   </span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">        error_page   500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #静态文件，nginx自己处理</span><br><span class="line">        location ~ ^/(images|javascript|js|css|flash|media|static)/ &#123;</span><br><span class="line">            </span><br><span class="line">            #过期30天，静态文件不怎么更新，过期可以设大一点，</span><br><span class="line">            #如果频繁更新，则可以设置得小一点。</span><br><span class="line">            expires 30d;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ .php$ &#123;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        #禁止访问 .htxxx 文件</span><br><span class="line">            location ~ /.ht &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="nginx配置举例"><a href="#nginx配置举例" class="headerlink" title="nginx配置举例"></a>nginx配置举例</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">user  work;</span><br><span class="line">worker_processes 8;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">error_log  logs/error.log warn;</span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line">pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  65535;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> load modules compiled as Dynamic Shared Object (DSO)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">dso &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_fastcgi_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">    load ngx_http_rewrite_module.so;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">&#125;</span></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    server_names_hash_bucket_size 128;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush      on;</span><br><span class="line">    tcp_nodelay     on;</span><br><span class="line"></span><br><span class="line">    fastcgi_connect_timeout 5;</span><br><span class="line">    fastcgi_send_timeout 10;</span><br><span class="line">    fastcgi_read_timeout 10;</span><br><span class="line">    fastcgi_buffer_size 64k;</span><br><span class="line">    fastcgi_buffers 4 64k;</span><br><span class="line">    fastcgi_busy_buffers_size 128k;</span><br><span class="line">    fastcgi_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  60;</span><br><span class="line">    keepalive_requests 1024;</span><br><span class="line">    client_header_buffer_size 4k;</span><br><span class="line">    large_client_header_buffers 4 32k;</span><br><span class="line">    client_max_body_size 10m;</span><br><span class="line"></span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    client_body_timeout 600;</span><br><span class="line">    client_header_timeout 600;</span><br><span class="line">    send_timeout 600;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout   1000ms;</span><br><span class="line">    proxy_send_timeout      2000000ms;</span><br><span class="line">    proxy_read_timeout      2000000ms;</span><br><span class="line">    proxy_buffers           64 8k;</span><br><span class="line">    proxy_busy_buffers_size    128k;</span><br><span class="line">    proxy_temp_file_write_size 64k;</span><br><span class="line">    proxy_redirect off;</span><br><span class="line">    #proxy_next_upstream off ;</span><br><span class="line"></span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 2;</span><br><span class="line">    gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    add_header X-Frame-Options &quot;ALLOW-FROM  http://cloud.njsig.cn&quot;;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Real-Port $remote_port;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">        &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_cookie&quot; &quot;$http_user_agent&quot; &#x27;</span><br><span class="line">        &#x27;$request_time $remote_addr $server_addr $upstream_addr $host &#x27;</span><br><span class="line">        &#x27;&quot;$http_x_forwarded_for&quot; $upstream_response_time&#x27;;</span><br><span class="line"></span><br><span class="line">    set_real_ip_from 10.0.0.0/8;</span><br><span class="line">    real_ip_header X-Real-IP;</span><br><span class="line"></span><br><span class="line">    #example</span><br><span class="line"><span class="meta">#</span><span class="bash">     server &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        listen 8000;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        server_name www;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        access_log logs/access.log  main;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        location / &#123;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">            proxy_pass http://127.0.0.1:8001;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      &#125;</span></span><br><span class="line">    include vhosts/*.conf;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">####</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name aaa.test.com bbb.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/opwf_access.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:8001;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="nginx-conf-vhosts-opwf-conf-django项目简单配置-1"><a href="#nginx-conf-vhosts-opwf-conf-django项目简单配置-1" class="headerlink" title="nginx/conf/vhosts/opwf.conf django项目简单配置"></a>nginx/conf/vhosts/opwf.conf django项目简单配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name ccc.test.com;</span><br><span class="line">        access_log  /home/work/nginx/logs/nj1_access.log main;</span><br><span class="line">        root /home/work/project/frontopwf/dist;</span><br><span class="line">        location / &#123;</span><br><span class="line">                try_files $uri $uri/ @router;</span><br><span class="line">        &#125;</span><br><span class="line">        location @router &#123;</span><br><span class="line">                rewrite ^.*$ /index.html last;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200302114623831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM</summary>
      
    
    
    
    <category term="nginx" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/nginx/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Docker 介绍，Linux简单安装</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/18/Docker%20%E4%BB%8B%E7%BB%8D%EF%BC%8CLinux%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/18/Docker%20%E4%BB%8B%E7%BB%8D%EF%BC%8CLinux%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85/</id>
    <published>2020-08-17T16:09:56.000Z</published>
    <updated>2020-09-13T11:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center" alt="在这里插入图片描述"></p><p>什么是 Docker？</p><ul><li>一个简单的应用程序打包工具</li><li>使用最广泛的开源容器</li><li>一种操作系统级的虚拟化技术</li><li>依赖于Linux内核特性：Namespace 和 Cgroups</li></ul><ol><li>Docker 是应用最广泛的开源容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中</li><li>然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。</li><li>每个容器拥有一套和宿主机完全隔离的文件系统（共用linux内核），程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。</li></ol><h5 id="容器："><a href="#容器：" class="headerlink" title="容器："></a>容器：</h5><ol><li><p>容器是一个操作系统级别下的虚拟化技术，运行一个容器就行运行一个进程一样</p></li><li><p>容器依赖linux内核特性：Namespace（资源隔离）和Cgroups（资源限制）</p></li></ol><p>Docker的设计目标</p><ul><li><p>提供了简单的应用程序打包</p></li><li><p>开发人员和运维人员职责逻辑分离</p></li><li><p>多环境保持一致性</p></li></ul><p>Docker的思想</p><ol><li><p>Docker的思想源于集装箱，集装箱解决了什么问题呢？</p></li><li><p>在早期运输货物需要不同分类的船，例如运输水果的船，运输生活用品的船</p></li><li><p>有了集装箱后，在大船上，可以把货物分类到不同的集装箱中，水果一个集装箱，生活用品一个集装箱</p></li><li><p>它们之间互不影响，只要把货物封装好集装箱里，就可以把不同类的货物一起运走。</p></li><li><p>通过Docker logo也可以看出所以然来，Docker就像大船，集装箱就是容器。</p></li><li><p>一条鲸鱼拖着若干个集装箱的经典形象已经深入人心。</p></li></ol><p>Docker的基本组成</p><p><img src="https://img-blog.csdnimg.cn/20200301141951332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th>DockerClient</th><th>客户端</th></tr></thead><tbody><tr><td>Docker Daemon</td><td>守护进程</td></tr><tr><td>Docker Images</td><td>镜像</td></tr><tr><td>Docker Container</td><td>容器</td></tr><tr><td>Docker Registry</td><td>镜像仓库</td></tr></tbody></table><p>虚拟机 和 容器</p><p><img src="https://img-blog.csdnimg.cn/20200301143040376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>VM</p><table><thead><tr><th>Infrastructure</th><th>代表他 可以是 台式 笔记本 服务器 云主机</th></tr></thead><tbody><tr><td>Hypervisor</td><td>运行在物理设备上 和 操作糸统之间的 中间软件管理层 ，也叫 宿主机</td></tr><tr><td>Guest OS</td><td>虚拟出的系统</td></tr><tr><td>Bins/Libx</td><td>二进制文件 / 库</td></tr><tr><td>App</td><td>部署的应用</td></tr></tbody></table><p>Container</p><table><thead><tr><th>Infrastructure</th><th>代表他 可以是 台式 笔记本 服务器 云主机</th></tr></thead><tbody><tr><td>Host OS</td><td>主机OS，这台机器的操作系统</td></tr><tr><td>Docker</td><td>系统级别的虚拟化技术，所以要基于已有的操作系统之上</td></tr><tr><td>Bins/Libx</td><td>二进制文件 / 库</td></tr><tr><td>App</td><td>部署的应用</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20200301150926289.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200301150947377.png" alt="在这里插入图片描述"></p><p>由上图可看 容器呢 只包含了 二进制文件 和 库、应用程序，而虚拟机是 Guest OS 承载的 二进制文件 和 库、应用程序</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table><thead><tr><th></th><th>Container</th><th>VM</th></tr></thead><tbody><tr><td>启动速度</td><td>秒级</td><td>分钟级</td></tr><tr><td>运动性能</td><td>接近原生</td><td>5%左右损失</td></tr><tr><td>磁盘占用</td><td>MB</td><td>GB</td></tr><tr><td>数量</td><td>成百上千</td><td>一般几十台</td></tr><tr><td>隔离性</td><td>进程级别</td><td>系统级（更彻底）</td></tr><tr><td>操作系统</td><td>只支持Linux</td><td>几乎所有</td></tr><tr><td>封装程度</td><td>只打包项目代码和依赖关系，共享宿主机内核</td><td>完整的操作系统</td></tr></tbody></table><h5 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h5><ol><li>docker设计小巧，部署迁移快速，运行高效，按照应用隔离，管理人员可以看到所有容器的内容。</li><li>虚拟化技术比较臃肿，需要先创建新的系统，按照系统隔离，管理员无法看到系统内部信息。</li></ol><h5 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h5><ul><li><p>Docker就是手机中的各种APP，只需要一个系统就可以下载自己所需的应用</p></li><li><p>虚拟化技术相当于苹果手机安装一个庞大软件，这个软件上安装安卓系统、魅族系统等，每个系统上还要安装各类应用。</p></li></ul><p>Docker 的应用场景</p><ul><li>应用程序打包和发布</li><li>应用程序隔离</li><li>持续集成</li><li>部署微服务</li><li>快速搭建测试环境</li><li>提供Paas产品（平台即服务）</li></ul><h5 id="详解："><a href="#详解：" class="headerlink" title="详解："></a>详解：</h5><ul><li><p>节省项目环境部署时间</p><ul><li><strong>单项目打包</strong></li></ul><ol><li>每次部署项目到测试、生产等环境，都要部署一大堆依赖的软件、工具，时间久，出错概率大。</li><li>Docker主要理念就是环境打包部署，可在任意Docker Engine运行。</li><li>我们只需要将每个项目环境打包到镜像，push到镜像仓库，当有需要部署这个项目时，直接pull镜像启动容器，这个项目就可以访问了！一次构建多次部署，一劳永逸。</li></ol><ul><li><strong>整套项目打包</strong></li></ul><ol><li>比如有一个产品可以整套部署到客户那里，以往都是派一名实施工程师到客户那部署。</li><li>如果用了Docker，我们可以前期将这套项目封装打包起来，实现一键部署，分分钟钟搞定，就不需要再派人过去了。比如官方的Docker Compose编排工具。</li></ol><ul><li><strong>新开源技术试用</strong></li></ul><ol><li>有时，我们想调研一些开源项目，我们可以直接从公共镜像仓库pull项目官方做好镜像启动容器即可。</li></ol></li><li><p>环境一致性</p></li></ul><ol><li>项目在开发电脑本地运行没问题，到了测试或生产环境就运行不起来。</li><li>Docker将项目环境打包成镜像，可以在任何Docker Engine部署。</li></ol><ul><li>持续集成</li></ul><ol><li>一个项目版本快速迭代的测试场景，需要一个合理的CI（持续集成）/CD（持续部署）环境支撑。</li><li>CI/CD是一个周期性自动化项目测试流程，包括构建、部署、测试、发布等工作，很少需要人工干预。</li><li>Docker通过项目镜像构建和快速部署，打通测试环境与生产环境，高度保持多个环境之间一致性。</li></ol><ul><li>微服务</li></ul><ol><li><p>微服务指尽可能细粒度拆分业务程序架构，由多个独立服务组成业务系统。</p></li><li><p>Docker容器作为这些独立服务的部署单元，每个服务单独部署到一个docker容器中。</p></li></ol><p>Linux 上安装 Docker</p><h5 id="docker版本"><a href="#docker版本" class="headerlink" title="docker版本"></a>docker版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker V1.13 版本的时候区分的 以下两个版本，大约是在17年初，我们用的是 最新版 V18.03</span><br></pre></td></tr></table></figure><ol><li>社区版（Community Edition, CE）</li><li>企业版（Enterprise Edition, EE）</li></ol><h4 id="docker安装参考官方文档"><a href="#docker安装参考官方文档" class="headerlink" title="docker安装参考官方文档"></a>docker安装参考官方文档</h4><ol><li>docker官方文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a></li><li>centos安装docker：<a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a><br><code>注：docker CE只支持 centos7 不支持centos6</code></li></ol><p><img src="https://img-blog.csdnimg.cn/20200301222519716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.安装依赖包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.添加Docker软件包源(否则doker安装的不是新版本)</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装Docker CE</span></span><br><span class="line">yum install -y docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.启动Docker服务并设置开机启动</span></span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.测试docker是否安装成功（hello-world是官方提供的一个测试镜像）</span></span><br><span class="line">docker run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看docker基本信息</span></span><br><span class="line">docker info</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h5 id="docker简单使用-创建Nginx容器"><a href="#docker简单使用-创建Nginx容器" class="headerlink" title="docker简单使用 创建Nginx容器"></a>docker简单使用 创建Nginx容器</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、创建一个nginx容器</span></span><br><span class="line">docker run -it nginx</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、查看docker运行的容器(可以获取到这个容器的id)</span></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、访问这个容器</span></span><br><span class="line"><span class="comment"># 进入这个nginx容器（进入的文件系统和宿主机是完全隔离的，有自己独立的文件系统）</span></span><br><span class="line">docker <span class="keyword">exec</span> -it <span class="number">73877e65</span>c07d bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、查看当前容器的 IP</span></span><br><span class="line">docker inspect <span class="number">73877e65</span>c07d   <span class="comment"># 73877e65c07d是通过docekr ps查看到的容器ID</span></span><br><span class="line">curl <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>               <span class="comment"># 测试这个nginx容器是否可以访问</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200301143418334.jpg#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;什么是 Docker？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个简单的应用程序打包工具&lt;/l</summary>
      
    
    
    
    <category term="docker" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/docker/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Django 支付宝 扫码支付</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/12/Python%20Django%20%E6%94%AF%E4%BB%98%E5%AE%9D%20%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/12/Python%20Django%20%E6%94%AF%E4%BB%98%E5%AE%9D%20%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98/</id>
    <published>2020-08-12T04:00:19.000Z</published>
    <updated>2020-09-13T11:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>*</em>*安装python-alipay-sdk*\</strong>***</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-alipay-sdk --upgrade</span><br></pre></td></tr></table></figure><p><strong><em>\</em>原理介绍：**</strong></p><p>　　1.进行秘钥配置，因为传输的数据必须要进行签名加密，ubuntu内置命令openssl可以生成私钥，根据私钥生成公钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　openssl</span><br><span class="line">　　OpenSSL&gt; genrsa -out app_private_key.pem   2048  # 私钥 2048对应的是rsa加密时候的复杂程度，即rsa2</span><br><span class="line">　　OpenSSL&gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥</span><br><span class="line">　　OpenSSL&gt; exit</span><br></pre></td></tr></table></figure><p>　　2.cat app_publict_key.pem 查看公钥的内容</p><p>　　将—–BEGIN PUBLIC KEY—–和—–END PUBLIC KEY—–中间的内容保存在支付宝的用户配置中（沙箱或者正式）</p><p>​    <a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></p><p>　　3.配置好公钥后，支付宝会生成公钥，将公钥的内容复制保存到一个文本文件中(alipay_pubilc_key.pem)，注意需要在文本的首尾添加标记位(—–BEGIN 　　PUBLIC KEY—–和—–END PUBLIC KEY—–) </p><p>　　4.将刚刚生成的私钥app_private_key.pem和支付宝公钥alipay_public_key.pem放到我们的项目目录中</p><p>　　5.使用支付宝 python包的初始化</p><p>　　6.调用支付接口</p><p>　　<a href="https://docs.open.alipay.com/270/alipay.trade.page.pay/">https://docs.open.alipay.com/270/alipay.trade.page.pay/</a></p><p>　　7.获取支付结果接口</p><p>　　<a href="https://docs.open.alipay.com/api_1/alipay.trade.query">https://docs.open.alipay.com/api_1/alipay.trade.query</a></p><p><strong><em>\</em>代码部分：**</strong></p><p>1.整个项目架构</p><p><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106213627440-1895798970.png" alt="img"></p><p>index.html代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;static&#x2F;js&#x2F;jquery-1.4.2.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        $(function () &#123;</span><br><span class="line">            $(&#39;#btn&#39;).click(function () &#123;</span><br><span class="line">                var order_id &#x3D; &quot;20180105002&quot;;</span><br><span class="line">                var req_data &#x3D; &#123;</span><br><span class="line">                    order_id: order_id,</span><br><span class="line">                    csrfmiddlewaretoken: &quot;&#123;&#123; csrf_token &#125;&#125;&quot;</span><br><span class="line">                &#125;;</span><br><span class="line">                $.post(&quot;&#x2F;pay&#x2F;&quot;, req_data, function (data) &#123;</span><br><span class="line">                    window.open(data.url)</span><br><span class="line">                &#125;);</span><br><span class="line">                $.get(&quot;&#x2F;check_pay&#x2F;?order_id&#x3D;&quot; + order_id, function (data) &#123;</span><br><span class="line">                    if (0 &#x3D;&#x3D; data.code) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 支付成功</span><br><span class="line">                        alert(&quot;支付成功&quot;);</span><br><span class="line">                        location.reload();</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        alert(data.message)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;支付&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>2.AppTest.views.py代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"></span><br><span class="line">from django.shortcuts import render</span><br><span class="line">from django.http import JsonResponse</span><br><span class="line">from alipay import AliPay</span><br><span class="line">import os</span><br><span class="line">from django.conf import settings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return render(request, &quot;index.html&quot;,locals())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pay(request):</span><br><span class="line">    order_id &#x3D; request.POST.get(&quot;order_id&quot;)</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA 或者 RSA2</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 电脑网站支付，需要跳转到https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do? + order_string</span><br><span class="line">    order_string &#x3D; alipay.api_alipay_trade_page_pay(</span><br><span class="line">        out_trade_no&#x3D;order_id,</span><br><span class="line">        total_amount&#x3D;str(0.01),  # 将Decimal类型转换为字符串交给支付宝</span><br><span class="line">        subject&#x3D;&quot;测试订单&quot;,</span><br><span class="line">        return_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&quot;,</span><br><span class="line">        notify_url&#x3D;&quot;https:&#x2F;&#x2F;example.com&#x2F;notify&quot;  # 可选, 不填则使用默认notify url</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    # 让用户进行支付的支付宝页面网址</span><br><span class="line">    url &#x3D; settings.ALIPAY_URL + &quot;?&quot; + order_string</span><br><span class="line"></span><br><span class="line">    return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;请求支付成功&quot;, &quot;url&quot;: url&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_pay(request):</span><br><span class="line">    # 创建用于进行支付宝支付的工具对象</span><br><span class="line">    order_id &#x3D; request.GET.get(&quot;order_id&quot;)</span><br><span class="line">    alipay &#x3D; AliPay(</span><br><span class="line">        appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">        app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">        app_private_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;app_private_key.pem&quot;),</span><br><span class="line">        alipay_public_key_path&#x3D;os.path.join(settings.BASE_DIR, &quot;AppTest&#x2F;alipay_public_key.pem&quot;),</span><br><span class="line">        # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,</span><br><span class="line">        sign_type&#x3D;&quot;RSA2&quot;,  # RSA2,官方推荐，配置公钥的时候能看到</span><br><span class="line">        debug&#x3D;True  # 默认False  配合沙箱模式使用</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        # 调用alipay工具查询支付结果</span><br><span class="line">        response &#x3D; alipay.api_alipay_trade_query(order_id)  # response是一个字典</span><br><span class="line">        # 判断支付结果</span><br><span class="line">        code &#x3D; response.get(&quot;code&quot;)  # 支付宝接口调用成功或者错误的标志</span><br><span class="line">        trade_status &#x3D; response.get(&quot;trade_status&quot;)  # 用户支付的情况</span><br><span class="line"></span><br><span class="line">        if code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;TRADE_SUCCESS&quot;:</span><br><span class="line">            # 表示用户支付成功</span><br><span class="line">            # 返回前端json，通知支付成功</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 0, &quot;message&quot;: &quot;支付成功&quot;&#125;)</span><br><span class="line"></span><br><span class="line">        elif code &#x3D;&#x3D; &quot;40004&quot; or (code &#x3D;&#x3D; &quot;10000&quot; and trade_status &#x3D;&#x3D; &quot;WAIT_BUYER_PAY&quot;):</span><br><span class="line">            # 表示支付宝接口调用暂时失败，（支付宝的支付订单还未生成） 后者 等待用户支付</span><br><span class="line">            # 继续查询</span><br><span class="line">            print(code)</span><br><span class="line">            print(trade_status)</span><br><span class="line">            continue</span><br><span class="line">        else:</span><br><span class="line">            # 支付失败</span><br><span class="line">            # 返回支付失败的通知</span><br><span class="line">            return JsonResponse(&#123;&quot;code&quot;: 1, &quot;message&quot;: &quot;支付失败&quot;&#125;)</span><br><span class="line"># Create your views here.</span><br></pre></td></tr></table></figure><p>3.主urls.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from django.contrib import admin</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, include(admin.site.urls)),</span><br><span class="line">    url(r&#39;^&#39;, include(&#39;AppTest.urls&#39;)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>4.AppTest urls.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from django.conf.urls import include, url</span><br><span class="line">from views import *</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&quot;^$&quot;, index),</span><br><span class="line">    url(r&quot;^pay&#x2F;$&quot;, pay),</span><br><span class="line">    url(r&quot;^check_pay&#x2F;$&quot;, check_pay),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>5.setttings.py中设置</p><p>修改templates部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES &#x3D; [</span><br><span class="line">    &#123;</span><br><span class="line">        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,</span><br><span class="line">        &#39;DIRS&#39;: [</span><br><span class="line">            os.path.join(BASE_DIR,&quot;template&quot;).replace(&quot;\\&quot;,&quot;&#x2F;&quot;)</span><br><span class="line">        ],</span><br><span class="line">        &#39;APP_DIRS&#39;: True,</span><br><span class="line">        &#39;OPTIONS&#39;: &#123;</span><br><span class="line">            &#39;context_processors&#39;: [</span><br><span class="line">                &#39;django.template.context_processors.debug&#39;,</span><br><span class="line">                &#39;django.template.context_processors.request&#39;,</span><br><span class="line">                &#39;django.contrib.auth.context_processors.auth&#39;,</span><br><span class="line">                &#39;django.contrib.messages.context_processors.messages&#39;,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>末尾加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STATIC_URL &#x3D; &#39;&#x2F;static&#x2F;&#39;</span><br><span class="line">STATICFILES_DIRS &#x3D; [os.path.join(BASE_DIR, &quot;static&quot;)]</span><br><span class="line"></span><br><span class="line"># 支付宝配置参数</span><br><span class="line">ALIPAY_APPID &#x3D; &quot;2017072407880788&quot;</span><br><span class="line">ALIPAY_URL &#x3D; &quot;https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do&quot;</span><br></pre></td></tr></table></figure><p><strong>测试效果：</strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214211659-814207984.png" alt="img"></strong></p><p><strong><img src="https://images2017.cnblogs.com/blog/1265917/201801/1265917-20180106214152831-470859591.png" alt="img"></strong></p><p>返回结果</p><p><a href="https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21:28:38&amp;sign=fg19hD85DPPuN1aaI++skuomKUxaDGE/dvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e/jAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW+yEO8pWQ8c+S8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k+ylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy+HYZZVsv5lYg+rb87eM6Yz7xwUe5v5dDEoz/OLjsuB0GDRTdvhHqs39cGIoMXFfEpbw==&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0">https://example.com/?total_amount=0.01&amp;timestamp=2018-01-06+21%3A28%3A38&amp;sign=fg19hD85DPPuN1aaI%2B%2BskuomKUxaDGE%2FdvyttEyV3vubVkVvBDXVziZaGybXqZs5o4bXYojx587qNBb8e%2FjAJOBCwKwYZxd7qR3AKlVabkPDzEOlzvEaSW7HTQpsWsVeX6BW%2ByEO8pWQ8c%2BS8B8tS8a8AFtQxeW92as4hdNjQU2YBZ2SVxtKSohWbFWpny1gDWXinQ3y2HNo4t5lmA8fRknB0MaUPwR1SzWa0k%2BylYjpWEnzC6OihP0Er21Ad8fiUwtSxZqH4xIAhnbofAy%2BHYZZVsv5lYg%2Brb87eM6Yz7xwUe5v5dDEoz%2FOLjsuB0GDRTdvhHqs39cGIoMXFfEpbw%3D%3D&amp;trade_no=2018010621001004260217512776&amp;sign_type=RSA2&amp;auth_app_id=2017072407880788&amp;charset=utf-8&amp;seller_id=2088221936946848&amp;method=alipay.trade.page.pay.return&amp;app_id=2017072407880788&amp;out_trade_no=20180105002&amp;version=1.0</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;*&lt;/em&gt;*安装python-alipay-sdk*\&lt;/strong&gt;***&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="支付宝扫码" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch 索引、类型、文档。接口的方式 CURD</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/05/ElasticSearch%20%E7%B4%A2%E5%BC%95%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%87%E6%A1%A3%E3%80%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%20CURD/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/05/ElasticSearch%20%E7%B4%A2%E5%BC%95%E3%80%81%E7%B1%BB%E5%9E%8B%E3%80%81%E6%96%87%E6%A1%A3%E3%80%82%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E5%BC%8F%20CURD/</id>
    <published>2020-08-05T07:01:55.000Z</published>
    <updated>2020-09-13T09:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/gwd1154978352/article/details/82740424">参考文档：https://blog.csdn.net/gwd1154978352/article/details/82740424</a></p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>索引是ElasticSearch存放数据的地方，可以理解为Mysql中的一个数据库。<br><code>你可以这么理解，你不能就说他是</code></p><p>我们的数据被 <strong>存储和索引在分片(shards)中</strong>，索引只是一个 把一个或多个分片分组在一起的逻辑空间。（就好像说）<code>这是一些内部细节我们不用关心分片。</code></p><p>对于我们的程序而言，文档存储在索引(index)中。剩下的细节由Elasticsearch关心既可。（索引的名字必须是全部小写，不能以下划线开头，不能包含逗号）</p><p><img src="https://img-blog.csdnimg.cn/20200612235843673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>类型用于区分同一个索引下不同的数据类型，相当于MySQL中的表。在Elasticsearch中，我们使用相同类型(type)的文档表示相同的“事物”，因为他们的数据结构也是相同的。每个类型(type)都有自己的映射(mapping)或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的映射(mapping)会告诉Elasticsearch不同的文档如何被索引。</p><p><img src="https://img-blog.csdnimg.cn/20200613000326776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个还是比较好理解的</p><h5 id="注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型"><a href="#注：5-0版本之前，一个索引可以对应多个类型。5-0版本之后，一个索引只能对应一个类型" class="headerlink" title="注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型"></a><code>注：5.0版本之前，一个索引可以对应多个类型。5.0版本之后，一个索引只能对应一个类型</code></h5><p><img src="https://img-blog.csdnimg.cn/20200613000611305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p>文档是ElasticSearch中存储的实体，类比MySQL，每个文档相当于数据库表中的一行数据。 在Elasticsearch中，文档 <strong>(document)</strong> 这个术语有着特殊含义。它特指最顶层结构或者根对象(root object)序列化成的JSON数据（以唯一ID标识并存储于Elasticsearch中）。<br>文档由字段组成，相当于关系数据库中列的属性，不同的是ES的不同文档可以具有不同的字段集合。<br>对比关系型数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h4 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h4><p>一个文档不只有数据。它还包含了元数据(metadata)——关于文档的信息。三个必须的元数据节点是：</p><table><thead><tr><th>节点</th><th>说明</th></tr></thead><tbody><tr><td>_index</td><td>文档存储的地方</td></tr><tr><td>_type</td><td>文档代表的对象的类</td></tr><tr><td>_id</td><td>文档的唯一标识</td></tr></tbody></table><ul><li>_index：索引</li><li>_type：类型</li><li>_id：id仅仅是一个字符串，它与_index和_type组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，<code>你可以自定义_id，也可以让Elasticsearch帮你自动生成。</code></li></ul><p>说的也就是这个 ↓<br><img src="https://img-blog.csdnimg.cn/20200613001612214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="索引创建的规则"><a href="#索引创建的规则" class="headerlink" title="索引创建的规则"></a>索引创建的规则</h4><ul><li>类似的数据放在一个索引，非类似的数据放不同索引</li><li>index中包含了很多类似的document</li><li>索引名称必须是小写的，不能用下划线开头，不能包含逗号：product，website，blog</li></ul><h4 id="创建索引、类型、文档（接口的方式）"><a href="#创建索引、类型、文档（接口的方式）" class="headerlink" title="创建索引、类型、文档（接口的方式）"></a>创建索引、类型、文档（接口的方式）</h4><p>刚才大家也看到了我的截图是在 Kibana上操作的，但现在书写的是以 接口的方式创建，Kibana 会在后续更新出来。</p><p>就随便写写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type:application/json&#x27;</span> -XPUT http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span> -d <span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      &quot;</span>private_id<span class="string">&quot;: &quot;</span><span class="number">1</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>title<span class="string">&quot;: &quot;</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>content<span class="string">&quot;: &quot;</span>I Really Really, really like yo<span class="string">u&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>tags<span class="string">&quot;: [&quot;</span>elasticsearch<span class="string">&quot;, &quot;</span>Love Lette<span class="string">r&quot;]</span></span><br><span class="line"><span class="string">&#125;&quot;</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>执行后 就会OK了，大家看到我在 类型的后面写了个 1，这个1 就代表了ID。如果不写的话 系统会自动生成的id，长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突。</p><p>就比如这条数据，我们更新他 <code>更新就不要用 put了，会error</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type:application/json&#x27;</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/ -d <span class="string">&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">      &quot;</span>private_id<span class="string">&quot;: &quot;</span><span class="number">1</span><span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>title<span class="string">&quot;: &quot;</span>This <span class="keyword">is</span> an interesting piece of data<span class="string">&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>content<span class="string">&quot;: &quot;</span>I Really Really, really like yo<span class="string">u&quot;,</span></span><br><span class="line"><span class="string">      &quot;</span>tags<span class="string">&quot;: [&quot;</span>elasticsearch<span class="string">&quot;, &quot;</span>Love Lette<span class="string">r&quot;]</span></span><br><span class="line"><span class="string">&#125;&quot;</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;Only_for_you&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_type&quot;</span> : <span class="string">&quot;testing_data&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;oJVnqXIBlXk7LCfggxrl&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_version&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;result&quot;</span> : <span class="string">&quot;updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;total&quot;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;successful&quot;</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;failed&quot;</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;_seq_no&quot;</span> : <span class="number">2</span>,</span><br><span class="line">  <span class="string">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br><span class="line">这里简单的概述下：POST 和 PUT 上的区别</span><br></pre></td></tr></table></figure><ul><li>POST不用加具体的id，它是作用在一个集合资源之上的（/uri）</li><li>PUT操作是作用在一个具体资源之上的（/uri/xxx），所以要指定ID</li></ul><h4 id="查看文档"><a href="#查看文档" class="headerlink" title="查看文档"></a>查看文档</h4><p>查看的话，方法很多种。</p><ul><li><p>浏览器直接 拼地址</p><p><img src="https://img-blog.csdnimg.cn/20200613005052905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>使用ES浏览器插件</p><p><img src="https://img-blog.csdnimg.cn/20200613005208881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://download.csdn.net/download/weixin_44685869/12518847">插件地址：https://download.csdn.net/download/weixin_44685869/12518847</a><br>我已经上传到我的 CSDN上传里了，你们可以在那里面找</p></li><li><p>在Linux中使用如下脚本：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#x27;Content-Type:application/json&#x27; -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="美化返回结果"><a href="#美化返回结果" class="headerlink" title="美化返回结果"></a>美化返回结果</h5><p>返回的响应包含了现在熟悉的元数据节点，增加了<code>_source</code>字段，它包含了在创建索引时我们发送给Elasticsearch的原始文档。</p><ul><li>pretty：在任意的查询字符串中增加pretty参数，类似于上面的例子。会让Elasticsearch美化输出(pretty-print)JSON响应以便更加容易阅读。</li><li>_source字段不会被美化，它的样子与我们输入的一致，现在只包含我们请求的字段，而且过滤了date字段。</li></ul><p>如果你只想得到_source字段而不要其他的元数据，你可以这样请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type:application/json&#x27;</span> -XGET http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_source</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="返回响应头消息"><a href="#返回响应头消息" class="headerlink" title="返回响应头消息"></a>返回响应头消息</h5><p>请求返回的响应内容包括 {“found”: true}。这意味着文档已经找到。如果我们请求一个不存在的文档，依旧会得到一个JSON，不过found值变成了false。此外，HTTP响应状态码也会变成’404 Not Found’代替’200 OK’。我们可以在curl后加-i参数得到响应头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#x27;Content-Type:application/json&#x27; -i -XGET http://localhost:9200/Only_for_you/testing_data/1?pretty</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>返回结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">content-type: application/json; charset=UTF<span class="number">-8</span></span><br><span class="line">content-length: <span class="number">337</span></span><br><span class="line"></span><br><span class="line">*********** 以下数据省略 ************</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h4 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&#x27;Content-Type:application/json&#x27;</span> -XPOST http://localhost:<span class="number">9200</span>/Only_for_you/testing_data/<span class="number">1</span>/_update -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;script&quot;: &quot;ctx._source.content = \&quot;new content\&quot;&quot;</span></span><br><span class="line"><span class="string">123</span></span><br></pre></td></tr></table></figure><h4 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XDELETE http://localhost:<span class="number">9200</span>/blog/article/<span class="number">1</span> </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="增删改查-简单的概述下"><a href="#增删改查-简单的概述下" class="headerlink" title="增删改查 简单的概述下"></a>增删改查 简单的概述下</h4><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>POST</td><td>/uri 创建</td></tr><tr><td>DELETE</td><td>/uri/xxx 删除</td></tr><tr><td>PUT</td><td>/uri/xxx 更新或创建</td></tr><tr><td>GET</td><td>/uri/xxx 查看</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gwd1154978352/article/details/82740424&quot;&gt;参考文档：https://blog.csdn.net/gwd1154978352/article/details/82740424&lt;</summary>
      
    
    
    
    <category term="ES检索" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/ES%E6%A3%80%E7%B4%A2/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>什么是ElasticSearch？</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/08/01/ElasticSearch%20%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/08/01/ElasticSearch%20%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-08-01T04:09:00.000Z</published>
    <updated>2020-09-17T13:56:53.880Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="什么是ElasticSearch？"><a href="#什么是ElasticSearch？" class="headerlink" title="什么是ElasticSearch？"></a>什么是ElasticSearch？</h4><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—无论是开源还是私有。</p><p>Lucece 这个 可是个很牛逼的东西，整理好资料我会在接下来的博客中 发布。</p><p><strong>优点</strong>：</p><ul><li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li><li>一个分布式实时分析搜索引擎</li><li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li></ul><p>Elasticsearch 可以横向扩展至数百（甚至数千）的服务器节点，同时可以处理PB级数据。Elasticsearch 天生就是分布式的，并且在设计时屏蔽了分布式的复杂性。</p><h4 id="用它来干什么"><a href="#用它来干什么" class="headerlink" title="用它来干什么?"></a>用它来干什么?</h4><p>Elasticsearch 是将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端 和 命令行 去充当这个客户端。</p><p>Elasticsearch 在速度和可扩展性方面都表现出色，而且还能够索引多种类型的内容，这意味着其可用于多种用例：</p><ul><li>应用程序搜索</li><li>网站搜索</li><li>企业搜索</li><li>日志处理和分析</li><li>基础设施指标和容器监测</li><li>应用程序性能监测</li><li>地理空间数据分析和可视化</li><li>安全分析</li><li>业务分析</li></ul><h4 id="为何使用-Elasticsearch？"><a href="#为何使用-Elasticsearch？" class="headerlink" title="为何使用 Elasticsearch？"></a>为何使用 Elasticsearch？</h4><p>Elasticsearch 快，真男人的那种快。 由于 Elasticsearch 是在 Lucene 基础上构建而成的，所以在全文本搜索方面表现十分牛逼。Elasticsearch 同时还是一个近实时的搜索平台，这意味着从文档索引操作到文档变为可搜索状态之间的延时很短，一般只有一秒。因此，Elasticsearch 非常适用于对时间有严苛要求的用例，例如安全分析和基础设施监测。</p><p>Elasticsearch 具有<code>分布式</code>的本质特征。 Elasticsearch 中<code>存储的文档分布在不同的容器中</code>，这些容器称为分片，可以进行复制以提供数据冗余副本，以防发生硬件故障。Elasticsearch 的分布式特性使得它可以扩展至数百台（甚至数千台）服务器，并处理 PB 量级的数据。</p><p>Elasticsearch 包含一系列广泛的功能。 除了速度、可扩展性和弹性等优势以外，Elasticsearch 还有大量强大的内置功能（例如数据汇总和索引生命周期管理），可以方便用户更加高效地存储和搜索数据。</p><p>Elastic Stack 简化了数据采集、可视化和报告过程。 通过与 Beats 和 Logstash 进行集成，用户能够在向 Elasticsearch 中索引数据之前轻松地处理数据。同时，Kibana 不仅可针对 Elasticsearch 数据提供实时可视化，同时还提供 UI 以便用户快速访问应用程序性能监测 (APM)、日志和基础设施指标等数据。</p><h4 id="elastic-search-在项目中的位置"><a href="#elastic-search-在项目中的位置" class="headerlink" title="elastic search 在项目中的位置"></a>elastic search 在项目中的位置</h4><p><img src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://img-blog.csdnimg.cn/20200612114228107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" class="lozad post-image"></p><h4 id="Elasticsearch-的工作原理是什么？"><a href="#Elasticsearch-的工作原理是什么？" class="headerlink" title="Elasticsearch 的工作原理是什么？"></a>Elasticsearch 的工作原理是什么？</h4><p>原始数据会从多个来源（包括日志、系统指标和网络应用程序）输入到 Elasticsearch 中。数据采集指在 Elasticsearch 中进行索引之前解析、标准化并充实这些原始数据的过程。这些数据在 Elasticsearch 中索引完成之后，用户便可针对他们的数据运行复杂的查询，并使用聚合来检索自身数据的复杂汇总。在 Kibana 中，用户可以基于自己的数据创建强大的可视化，分享仪表板，并对 Elastic Stack 进行管理。</p><h4 id="Elasticsearch-索引是什么？"><a href="#Elasticsearch-索引是什么？" class="headerlink" title="Elasticsearch 索引是什么？"></a>Elasticsearch 索引是什么？</h4><p>Elasticsearch 索引指相互关联的文档集合。Elasticsearch 会以 JSON 文档的形式存储数据。每个文档都会在一组键（字段或属性的名称）和它们对应的值（字符串、数字、布尔值、日期、数值组、地理位置或其他类型的数据）之间建立联系。</p><p>Elasticsearch 使用的是一种名为 <strong>倒排索引</strong> 的数据结构，这一结构的设计可以允许十分快速地进行全文本搜索。倒排索引会列出在所有文档中出现的每个特有词汇，并且可以找到包含每个词汇的全部文档。</p><p>在索引过程中，Elasticsearch 会存储文档并构建倒排索引，这样用户便可以近实时地对文档数据进行搜索。索引过程是在索引 API 中启动的，通过此 API 您既可向特定索引中添加 JSON 文档，也可更改特定索引中的 JSON 文档。</p><pre class="highlight"><span class="line">ELK &#x3D; Elasticsearch, Logstash, Kibana 是一套实时数据收集，存储，索引，检索，统计分析及可视化的解决方案。最新版本已经改名为Elastic Stack，并新增了Beats项目。</span><br></pre><h4 id="Logstash-的用途是什么？"><a href="#Logstash-的用途是什么？" class="headerlink" title="Logstash 的用途是什么？"></a>Logstash 的用途是什么？</h4><p>Logstash 是 Elastic Stack 的核心产品之一，可用来对数据进行聚合和处理，并将数据发送到 Elasticsearch。Logstash 是一个开源的服务器端数据处理管道，允许您在将数据索引到 Elasticsearch 之前同时从多个来源采集数据，并对数据进行充实和转换。</p><h4 id="Kibana-的用途是什么？"><a href="#Kibana-的用途是什么？" class="headerlink" title="Kibana 的用途是什么？"></a>Kibana 的用途是什么？</h4><p>Kibana 是用于 Elasticsearch 的数据可视化和管理工具，实时的提供直方图、线形图、饼状图和地图。Kibana 同时还包括诸如 Canvas 和 Elastic Maps 等高级应用程序；Canvas 允许用户基于自身数据创建定制的动态信息图表，而 Elastic Maps 则可用来对地理空间数据进行可视化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200611210137425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM</summary>
      
    
    
    
    <category term="ES检索" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/ES%E6%A3%80%E7%B4%A2/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin上传图片</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/07/22/Django%20Admin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/07/22/Django%20Admin%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</id>
    <published>2020-07-22T03:11:23.000Z</published>
    <updated>2020-09-13T09:11:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>Django有提供文件系统支持，在Admin站点中可以轻松上传图片。</p><p>使用Admin站点保存图片，需要安装Python的图片操作包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install Pillow</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h4><p>默认情况下，Django会将上传的图片保存在本地服务器上，需要配置保存的路径。</p><p>我们可以将上传的文件保存在静态文件目录中，如我们之前设置的static目录中在settings.py 文件中添加如下上传保存目录信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MEDIA_ROOT=os.path.join(BASE_DIR,<span class="string">&quot;static/media&quot;</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425223259996.png" alt="在这里插入图片描述"></p><h4 id="2-为模型类添加ImageField字段"><a href="#2-为模型类添加ImageField字段" class="headerlink" title="2 为模型类添加ImageField字段"></a>2 为模型类添加ImageField字段</h4><p>我们为之前的BookInfo模型类添加一个ImageFiled</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    image = models.ImageField(upload_to=<span class="string">&#x27;book&#x27;</span>, verbose_name=<span class="string">&#x27;图片&#x27;</span>, null=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    upload_to 选项指明该字段的图片保存在MEDIA_ROOT目录中的哪个子目录</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>进行数据库迁移操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations</span><br><span class="line">python manage.py migrate</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h4 id="3-使用Admin站点上传图片"><a href="#3-使用Admin站点上传图片" class="headerlink" title="3 使用Admin站点上传图片"></a>3 使用Admin站点上传图片</h4><p>进入Admin站点的图书管理页面，选择一个图书，能发现多出来一个上传图片的字段</p><p><img src="https://img-blog.csdnimg.cn/20200425223441314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>选择一张图片并保存后，图片会被保存在<code>static/media/book/</code>目录下。</p><p>在数据库中，我们能看到image字段被设置为图片的路径</p><p><img src="https://img-blog.csdnimg.cn/20200425223503320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;上传图片&quot;&gt;&lt;a href=&quot;#上传图片&quot; class=&quot;headerlink&quot; title=&quot;上传图片&quot;&gt;&lt;/a&gt;上传图片&lt;/h3&gt;&lt;p&gt;Django有提供文件系统支持，在Admin站点中可以轻松上传图片。&lt;/p&gt;
&lt;p&gt;使用Admin站点保存图片，需要安装Py</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin 调整站点信息（更改 Admin站点的名称信息）</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/07/16/Django%20Admin%20%E8%B0%83%E6%95%B4%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%88%E6%9B%B4%E6%94%B9%20Admin%E7%AB%99%E7%82%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF%EF%BC%89/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/07/16/Django%20Admin%20%E8%B0%83%E6%95%B4%E7%AB%99%E7%82%B9%E4%BF%A1%E6%81%AF%EF%BC%88%E6%9B%B4%E6%94%B9%20Admin%E7%AB%99%E7%82%B9%E7%9A%84%E5%90%8D%E7%A7%B0%E4%BF%A1%E6%81%AF%EF%BC%89/</id>
    <published>2020-07-15T16:22:09.000Z</published>
    <updated>2020-09-13T09:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调整站点信息"><a href="#调整站点信息" class="headerlink" title="调整站点信息"></a>调整站点信息</h3><p>Admin站点的名称信息也是可以自定义的。</p><p>未调整前如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200425222752410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><code>admin.site.site_header</code> 设置网站页头</li><li><code>admin.site.site_title</code> 设置页面标题</li><li><code>admin.site.index_title</code> 设置首页标语</li></ul><p>在 <code>admin.py</code> 文件中添加一下信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line">admin.site.site_header = <span class="string">&#x27;传智书城&#x27;</span></span><br><span class="line">admin.site.site_title = <span class="string">&#x27;传智书城MIS&#x27;</span></span><br><span class="line">admin.site.index_title = <span class="string">&#x27;欢迎使用传智书城MIS&#x27;</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>刷新网站，效果如下</p><p><img src="https://img-blog.csdnimg.cn/20200425223005559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;调整站点信息&quot;&gt;&lt;a href=&quot;#调整站点信息&quot; class=&quot;headerlink&quot; title=&quot;调整站点信息&quot;&gt;&lt;/a&gt;调整站点信息&lt;/h3&gt;&lt;p&gt;Admin站点的名称信息也是可以自定义的。&lt;/p&gt;
&lt;p&gt;未调整前如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python Admin 调整编辑页展示</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/07/09/Python%20Admin%20%E8%B0%83%E6%95%B4%E7%BC%96%E8%BE%91%E9%A1%B5%E5%B1%95%E7%A4%BA/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/07/09/Python%20Admin%20%E8%B0%83%E6%95%B4%E7%BC%96%E8%BE%91%E9%A1%B5%E5%B1%95%E7%A4%BA/</id>
    <published>2020-07-09T14:01:00.000Z</published>
    <updated>2020-09-13T09:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调整编辑页展示"><a href="#调整编辑页展示" class="headerlink" title="调整编辑页展示"></a>调整编辑页展示</h3><h4 id="1-显示字段"><a href="#1-显示字段" class="headerlink" title="1. 显示字段"></a>1. 显示字段</h4><p>属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fields=[]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1）点击某行ID的链接，可以转到修改页面，默认效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425220830424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    fields = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>]</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>3）刷新浏览器效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425220857597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-分组显示"><a href="#2-分组显示" class="headerlink" title="2. 分组显示"></a>2. 分组显示</h4><p>属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fieldsets=(</span><br><span class="line">    (<span class="string">&#x27;组1标题&#x27;</span>,&#123;<span class="string">&#x27;fields&#x27;</span>:(<span class="string">&#x27;字段1&#x27;</span>,<span class="string">&#x27;字段2&#x27;</span>)&#125;),</span><br><span class="line">    (<span class="string">&#x27;组2标题&#x27;</span>,&#123;<span class="string">&#x27;fields&#x27;</span>:(<span class="string">&#x27;字段3&#x27;</span>,<span class="string">&#x27;字段4&#x27;</span>)&#125;),</span><br><span class="line">)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># fields = [&#x27;name&#x27;, &#x27;pub_date&#x27;]</span></span><br><span class="line">    fieldsets = (</span><br><span class="line">        (<span class="string">&#x27;基本&#x27;</span>, &#123;<span class="string">&#x27;fields&#x27;</span>: [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;pub_date&#x27;</span>]&#125;),</span><br><span class="line">        (<span class="string">&#x27;高级&#x27;</span>, &#123;</span><br><span class="line">            <span class="string">&#x27;fields&#x27;</span>: [<span class="string">&#x27;readcount&#x27;</span>, <span class="string">&#x27;commentcount&#x27;</span>],</span><br><span class="line">            <span class="string">&#x27;classes&#x27;</span>: (<span class="string">&#x27;collapse&#x27;</span>,)  <span class="comment"># 是否折叠显示</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><ul><li>2）刷新浏览器效果如下图：<br><img src="https://img-blog.csdnimg.cn/20200425220934262.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><code>说明：fields与fieldsets两者选一使用。</code></li></ul><h4 id="3-关联对象"><a href="#3-关联对象" class="headerlink" title="3. 关联对象"></a>3. 关联对象</h4><p>在一对多的关系中，可以在一端的编辑页面中编辑多端的对象，嵌入多端对象的方式包括表格、块两种。</p><ul><li>类型InlineModelAdmin：表示在模型的编辑页面嵌入关联模型的编辑。</li><li>子类TabularInline：以表格的形式嵌入。</li><li>子类StackedInline：以块的形式嵌入。</li></ul><ul><li>1）打开book/admin.py文件，创建PeopleInfoStackInLine类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoStackInLine</span>(<span class="params">admin.StackedInline</span>):</span></span><br><span class="line">    model = PeopleInfo <span class="comment">#要关联的模型</span></span><br><span class="line">    extra = <span class="number">2</span> <span class="comment">#附加编辑的数量</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    inlines = [PeopleInfoStackInLine]</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><ul><li>3）刷新浏览器效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425222322288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以用表格的形式嵌入。</p><ul><li>1）打开book/admin.py文件，创建PeopleInfoTabularInline类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoTabularInline</span>(<span class="params">admin.TabularInline</span>):</span></span><br><span class="line">    model = PeopleInfo <span class="comment">#要关联的模型</span></span><br><span class="line">    extra = <span class="number">2</span> <span class="comment">#附加编辑的数量</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>2）打开book/admin.py文件，修改BookInfoAdmin类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    inlines = [PeopleInfoTabularInline]</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><ul><li>3）刷新浏览器效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425222424301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;调整编辑页展示&quot;&gt;&lt;a href=&quot;#调整编辑页展示&quot; class=&quot;headerlink&quot; title=&quot;调整编辑页展示&quot;&gt;&lt;/a&gt;调整编辑页展示&lt;/h3&gt;&lt;h4 id=&quot;1-显示字段&quot;&gt;&lt;a href=&quot;#1-显示字段&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin 列表页展示</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/07/04/Django%20Admin%20%E5%88%97%E8%A1%A8%E9%A1%B5%E5%B1%95%E7%A4%BA/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/07/04/Django%20Admin%20%E5%88%97%E8%A1%A8%E9%A1%B5%E5%B1%95%E7%A4%BA/</id>
    <published>2020-07-03T16:20:11.000Z</published>
    <updated>2020-09-13T08:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="调整列表页展示"><a href="#调整列表页展示" class="headerlink" title="调整列表页展示"></a>调整列表页展示</h3><h4 id="1-页大小"><a href="#1-页大小" class="headerlink" title="1 页大小"></a>1 页大小</h4><p>每页中显示多少条数据，默认为每页显示100条数据，属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_per_page=<span class="number">100</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>admin.py</code> 文件，修改 <code>AreaAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    list_per_page = <span class="number">2</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><ul><li>2）在浏览器中查看区域信息的列表页面，效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425215138294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="2-“操作选项”的位置"><a href="#2-“操作选项”的位置" class="headerlink" title="2 “操作选项”的位置"></a>2 “操作选项”的位置</h4><p>顶部显示的属性，设置为True在顶部显示，设置为False不在顶部显示，默认为True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actions_on_top=<span class="literal">True</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>底部显示的属性，设置为True在底部显示，设置为False不在底部显示，默认为False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actions_on_bottom=<span class="literal">False</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    actions_on_top = <span class="literal">True</span></span><br><span class="line">    actions_on_bottom = <span class="literal">True</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>2）在浏览器中刷新效果如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200425215506626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="3-列表中的列"><a href="#3-列表中的列" class="headerlink" title="3 列表中的列"></a>3 列表中的列</h4><p>属性如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list_display=[模型字段<span class="number">1</span>,模型字段<span class="number">2</span>,...]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    list_display = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><ul><li>2）在浏览器中刷新效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425215553301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>点击列头可以进行升序或降序排列。</strong></p><h4 id="4-将方法作为列"><a href="#4-将方法作为列" class="headerlink" title="4 将方法作为列"></a>4 将方法作为列</h4><p>列可以是模型字段，还可以是模型方法，要求方法有返回值。</p><p><strong>通过设置short_description属性，可以设置在admin站点中显示的列名。</strong></p><ul><li>1）打开 <code>models.py</code> 文件，修改 <code>BookInfo</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span> (<span class="params">models.Model</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&lt;&#x27;</span> + self.name + <span class="string">&#x27;&gt;&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    bookname.short_description = <span class="string">&#x27;书名&#x27;</span>  <span class="comment"># 设置方法字段在admin中显示的标题</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><ul><li>2）打开 <code>admin.py</code> 文件，修改 <code>BookInfoAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span> (<span class="params">admin.ModelAdmin</span>) :</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   list_display = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;bookname&#x27;</span>]</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>3）在浏览器中刷新效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/2020042521565783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法列是不能排序的，如果需要排序需要为方法指定排序依据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin_order_field=模型类字段</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>models.py</code>文件，修改 <code>BookInfo</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;&lt;&#x27;</span> + self.name + <span class="string">&#x27;&gt;&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line">    bookname.short_description = <span class="string">&#x27;书名&#x27;</span>  <span class="comment"># 设置方法字段在admin中显示的标题</span></span><br><span class="line">    bookname.admin_order_field = <span class="string">&#x27;name&#x27;</span></span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2）在浏览器中刷新效果如下图：<br><img src="https://img-blog.csdnimg.cn/20200425215738873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h4 id="5-关联对象"><a href="#5-关联对象" class="headerlink" title="5 关联对象"></a>5 关联对象</h4><p>无法直接访问关联对象的属性或方法，可以在模型类中封装方法，访问关联对象的成员。</p><ul><li>1）打开 <code>models.py</code> 文件，修改 <code>PeopleInfo</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfo</span>(<span class="params">models.Model</span>):</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">readcount</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.book.readcount</span><br><span class="line">    readcount.short_description = <span class="string">&#x27;图书阅读量&#x27;</span></span><br><span class="line"><span class="number">1234567</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）打开 <code>admin.py</code> 文件，修改 <code>PeopleInfoAdmin</code> 类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;readcount&#x27;</span>]</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）在浏览器中刷新效果如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200425215851420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="6-右侧栏过滤器"><a href="#6-右侧栏过滤器" class="headerlink" title="6 右侧栏过滤器"></a>6 右侧栏过滤器</h4><p>属性如下，只能接收字段，会将对应字段的值列出来，用于快速过滤。一般用于有重复值的字段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list_filter=[]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>1）打开 <code>admin.py</code> 文件，修改 <code>PeopleInfoAdmin</code> 类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;readcount&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    list_filter = [<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2）在浏览器中刷新效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425220055236.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="7-搜索框"><a href="#7-搜索框" class="headerlink" title="7 搜索框"></a>7 搜索框</h4><p>属性如下，用于对指定字段的值进行搜索，支持模糊查询。列表类型，表示在这些字段上进行搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search_fields=[]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>1）打开<code>admin.py</code>文件，修改<code>PeopleInfoAdmin</code>类如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(PeopleInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeopleInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line"></span><br><span class="line">    list_display = [<span class="string">&#x27;id&#x27;</span>,<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;readcount&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    list_filter = [<span class="string">&#x27;book&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    search_fields = [<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><ul><li>2）在浏览器中刷新效果如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425220702426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;调整列表页展示&quot;&gt;&lt;a href=&quot;#调整列表页展示&quot; class=&quot;headerlink&quot; title=&quot;调整列表页展示&quot;&gt;&lt;/a&gt;调整列表页展示&lt;/h3&gt;&lt;h4 id=&quot;1-页大小&quot;&gt;&lt;a href=&quot;#1-页大小&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django Admin站点</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/07/02/Django%20Admin%E7%AB%99%E7%82%B9/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/07/02/Django%20Admin%E7%AB%99%E7%82%B9/</id>
    <published>2020-07-02T04:55:00.000Z</published>
    <updated>2020-09-13T08:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Admin站点"><a href="#Admin站点" class="headerlink" title="Admin站点"></a>Admin站点</h3><p>假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？<strong>是从数据库中查找到新闻的信息，然后把它展示在页面上。</strong> 但是我们的网站上的新闻每天都要更新，这就意味着对数据库的增、删、改、查操作，那么我们需要每天写sql语句操作数据库吗? 如果这样的话，是不是非常繁琐，所以我们可以设计一个页面，通过对这个页面的操作来实现对新闻数据库的增删改查操作。那么问题来了，老板说我们需要在建立一个新网站，是不是还要设计一个页面来实现对新网站数据库的增删改查操作，但是这样的页面具有一个很大的重复性，那有没有一种方法能够让我们很快的生成管理数据库表的页面呢？<strong>有，那就是我们接下来要给大家讲的Django的后台管理</strong>。Django能够根据定义的模型类自动地生成管理页面。</p><p>使用Django的管理模块，需要按照如下步骤操作：</p><ol><li>管理界面本地化</li><li>创建管理员</li><li>注册模型类</li><li>自定义管理页面</li></ol><h4 id="1-管理界面本地化"><a href="#1-管理界面本地化" class="headerlink" title="1 管理界面本地化"></a>1 管理界面本地化</h4><p>在settings.py中设置语言和时区</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置中文</span></span><br><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-Hans&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#亚洲上海时区</span></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h4 id="2-创建超级管理员"><a href="#2-创建超级管理员" class="headerlink" title="2 创建超级管理员"></a>2 创建超级管理员</h4><p>创建管理员的命令如下，按提示输入用户名、邮箱、密码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425172151578.png" alt="在这里插入图片描述"></p><p>打开浏览器，在地址栏中输入如下地址后回车。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin/</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>输入前面创建的用户名、密码完成登录。</p><p><img src="https://img-blog.csdnimg.cn/2020042517221618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>登录成功后界面如下，但是并没有我们自己应用模型的入口，接下来进行第三步操作。</p><p><img src="https://img-blog.csdnimg.cn/20200425172234391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-注册模型类"><a href="#3-注册模型类" class="headerlink" title="3 注册模型类"></a>3 注册模型类</h3><p>登录后台管理后，默认没有我们创建的应用中定义的模型类，需要在自己应用中的admin.py文件中注册，才可以在后台管理中看到，并进行增删改查操作。</p><p>打开booktest/admin.py文件，编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="comment">#导入模型</span></span><br><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo,PeopleInfo</span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"><span class="comment">#注册书籍模型</span></span><br><span class="line">admin.site.register(BookInfo)</span><br><span class="line"><span class="comment">#注册人物模型</span></span><br><span class="line">admin.site.register(PeopleInfo)</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>到浏览器中刷新页面，可以看到模型类BookInfo和PeopleInfo的管理了。<br><img src="https://img-blog.csdnimg.cn/20200425172305673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>点击类名称”BookInfo”（图书）可以进入列表页，默认只有一列。<br><img src="https://img-blog.csdnimg.cn/20200425172318273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在列表页中点击”增加”可以进入增加页，Django会根据模型类的不同，生成不同的表单控件，按提示填写表单内容后点击”保存”，完成数据创建，创建成功后返回列表页。</p><p><img src="https://img-blog.csdnimg.cn/20200425172331888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在列表页中点击某行的第一列可以进入修改页。</p><p><img src="https://img-blog.csdnimg.cn/20200425172343482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按照提示进行内容的修改，修改成功后进入列表页。在修改页点击“删除”可以删除一项。</p><p><img src="https://img-blog.csdnimg.cn/20200425172357295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>删除：在列表页勾选想要删除的复选框，可以删除多项。</p><p><img src="https://img-blog.csdnimg.cn/20200425172410268.png" alt="在这里插入图片描述"><br>点击执行后进入确认页面，删除后回来列表页面。</p><p><img src="https://img-blog.csdnimg.cn/20200425172421776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-定义与使用Admin管理类"><a href="#4-定义与使用Admin管理类" class="headerlink" title="4 定义与使用Admin管理类"></a>4 定义与使用Admin管理类</h3><p>Django提供的Admin站点的展示效果可以通过自定义ModelAdmin类来进行控制。</p><p>定义管理类需要继承自admin.ModelAdmin类，如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>使用管理类有两种方式：</p><ul><li>注册参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin.site.register(BookInfo,BookInfoAdmin</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.register(BookInfo)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoAdmin</span>(<span class="params">admin.ModelAdmin</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Admin站点&quot;&gt;&lt;a href=&quot;#Admin站点&quot; class=&quot;headerlink&quot; title=&quot;Admin站点&quot;&gt;&lt;/a&gt;Admin站点&lt;/h3&gt;&lt;p&gt;假设我们要设计一个新闻网站，我们需要编写展示给用户的页面，网页上展示的新闻信息是从哪里来的呢？&lt;st</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django 模板 进阶</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/06/29/Django%20%E6%A8%A1%E6%9D%BF%20%E8%BF%9B%E9%98%B6/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/06/29/Django%20%E6%A8%A1%E6%9D%BF%20%E8%BF%9B%E9%98%B6/</id>
    <published>2020-06-29T03:09:27.000Z</published>
    <updated>2020-09-13T08:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-配置"><a href="#1-配置" class="headerlink" title="1 配置"></a>1 配置</h3><p>在工程中创建模板目录templates。</p><p>在settings.py配置文件中修改<strong>TEMPLATES</strong>配置项的DIRS值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="string">&#x27;templates&#x27;</span>)],  <span class="comment"># 此处修改</span></span><br><span class="line">        <span class="string">&#x27;APP_DIRS&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;context_processors&#x27;</span>: [</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.debug&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.template.context_processors.request&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="2-定义模板"><a href="#2-定义模板" class="headerlink" title="2 定义模板"></a>2 定义模板</h3><p>在templates目录中新建一个模板文件，如index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h3 id="3-模板渲染"><a href="#3-模板渲染" class="headerlink" title="3 模板渲染"></a>3 模板渲染</h3><p>调用模板分为两步骤：</p><ul><li>找到模板 loader.get_template(模板文件在模板目录中的相对路径) -&gt; 返回模板对象</li><li>渲染模板 模板对象.render(context=None, request=None) -&gt; 返回渲染后的html文本字符串 context 为模板变量字典，默认值为None request 为请求对象，默认值为None</li></ul><p>例如，定义一个视图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> django.template <span class="keyword">import</span> loader</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="comment"># 1.获取模板</span></span><br><span class="line">    template=loader.get_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    context=&#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 2.渲染模板</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(template.render(context))</span><br></pre></td></tr></table></figure><p>Django提供了一个函数render可以简写上述代码。</p><p>render(request对象, 模板文件路径, 模板数据字典)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    context=&#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request,<span class="string">&#x27;index.html&#x27;</span>,context)</span><br></pre></td></tr></table></figure><h3 id="4-模板语法"><a href="#4-模板语法" class="headerlink" title="4 模板语法"></a>4 模板语法</h3><h4 id="4-1-模板变量"><a href="#4-1-模板变量" class="headerlink" title="4.1 模板变量"></a>4.1 模板变量</h4><p>变量名必须由字母、数字、下划线（不能以下划线开头）和点组成。</p><p>语法如下：</p><p><img src="https://img-blog.csdnimg.cn/20200425123449754.png" alt="在这里插入图片描述"><br>模板变量可以使python的内建类型，也可以是对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    context = &#123;</span><br><span class="line">        <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;北京&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;adict&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;西游记&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;author&#x27;</span>: <span class="string">&#x27;吴承恩&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;alist&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;index.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200425123529482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="4-2-模板语句"><a href="#4-2-模板语句" class="headerlink" title="4.2 模板语句"></a>4.2 模板语句</h4><ol><li><p><strong>for循环：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200425123551840.png" alt="在这里插入图片描述"></p></li><li><p><strong>if条件：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200425123602818.png" alt="在这里插入图片描述"></p></li></ol><p>比较运算符如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==</span><br><span class="line">!=</span><br><span class="line">&lt;</span><br><span class="line">&gt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br></pre></td></tr></table></figure><p>布尔运算符如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line"><span class="keyword">not</span></span><br></pre></td></tr></table></figure><p><code>注意：运算符左右两侧不能紧挨变量或常量，必须有空格。</code><br><img src="https://img-blog.csdnimg.cn/20200425123741564.png" alt="在这里插入图片描述"></p><h3 id="4-3-过滤器"><a href="#4-3-过滤器" class="headerlink" title="4.3 过滤器"></a>4.3 过滤器</h3><p>语法如下:</p><ul><li>使用管道符号|来应用过滤器，用于进行计算、转换操作，可以使用在变量、标签中。</li><li>如果过滤器需要参数，则使用冒号:传递参数。</li><li>变量|过滤器:参数</li></ul><p>列举几个如下：</p><ul><li><p>safe，禁用转义，告诉模板这个变量是安全的，可以解释执行</p></li><li><p>length，长度，返回字符串包含字符的个数，或列表、元组、字典的元素个数。</p></li><li><p>default，默认值，如果变量不存在时则返回默认值。</p></li><li><pre><code class="python">data|default:&#39;默认值&#39;1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- date，日期，用于对日期类型的值进行字符串格式化，常用的格式化字符如下：</span><br><span class="line"></span><br><span class="line">  - Y表示年，格式为4位，y表示两位的年。</span><br><span class="line">  - m表示月，格式为01,02,12等。</span><br><span class="line">  - d表示日, 格式为01,02等。</span><br><span class="line">  - j表示日，格式为1,2等。</span><br><span class="line">  - H表示时，24进制，h表示12进制的时。</span><br><span class="line">  - i表示分，为0-59。</span><br><span class="line">  - s表示秒，为0-59。</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;python</span><br><span class="line">  value|date:&quot;Y年m月j日  H时i分s秒&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></code></pre></li></ul><h4 id="4-4-注释"><a href="#4-4-注释" class="headerlink" title="4.4 注释"></a>4.4 注释</h4><ol><li><p>单行注释语法如下：</p><p><img src="https://img-blog.csdnimg.cn/20200425124128434.png" alt="在这里插入图片描述"></p></li><li><p>多行注释使用comment标签，语法如下：</p><p><img src="https://img-blog.csdnimg.cn/20200425124140229.png" alt="在这里插入图片描述"></p></li></ol><h4 id="4-5-模板继承"><a href="#4-5-模板继承" class="headerlink" title="4.5 模板继承"></a>4.5 模板继承</h4><p>模板继承和类的继承含义是一样的，主要是为了提高代码重用，减轻开发人员的工作量。</p><p><strong>父模板</strong></p><p>如果发现在多个模板中某些内容相同，那就应该把这段内容定义到父模板中。</p><p>标签block：用于在父模板中预留区域，留给子模板填充差异性的内容，名字不能相同。 为了更好的可读性，建议给endblock标签写上名字，这个名字与对应的block名字相同。父模板中也可以使用上下文中传递过来的数据。</p><p><strong>子模板</strong></p><p>标签extends：继承，写在子模板文件的第一行。</p><p><img src="https://img-blog.csdnimg.cn/20200425124227805.png" alt="在这里插入图片描述"><br>子模版不用填充父模版中的所有预留区域，如果子模版没有填充，则使用父模版定义的默认值。</p><p><img src="https://img-blog.csdnimg.cn/202004251242407.png" alt="在这里插入图片描述"></p><p>填充父模板中指定名称的预留区域。</p><p><img src="https://img-blog.csdnimg.cn/20200425124255595.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-配置&quot;&gt;&lt;a href=&quot;#1-配置&quot; class=&quot;headerlink&quot; title=&quot;1 配置&quot;&gt;&lt;/a&gt;1 配置&lt;/h3&gt;&lt;p&gt;在工程中创建模板目录templates。&lt;/p&gt;
&lt;p&gt;在settings.py配置文件中修改&lt;strong&gt;TEMPLAT</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django 类视图 和 中间件</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/06/18/Django%20%E7%B1%BB%E8%A7%86%E5%9B%BE%20%E5%92%8C%20%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/06/18/Django%20%E7%B1%BB%E8%A7%86%E5%9B%BE%20%E5%92%8C%20%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2020-06-18T12:09:49.000Z</published>
    <updated>2020-09-13T08:47:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类视图"><a href="#类视图" class="headerlink" title="类视图"></a>类视图</h3><p>思考：一个视图，是否可以处理两种逻辑？比如get和post请求逻辑。</p><h4 id="如何在一个视图中处理get和post请求"><a href="#如何在一个视图中处理get和post请求" class="headerlink" title="如何在一个视图中处理get和post请求"></a>如何在一个视图中处理get和post请求</h4><p><img src="https://img-blog.csdnimg.cn/20200424201651517.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="注册视图处理get和post请求"><a href="#注册视图处理get和post请求" class="headerlink" title="注册视图处理get和post请求"></a>注册视图处理get和post请求</h4><p>以函数的方式定义的视图称为 <strong>函数视图</strong>，函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;处理注册&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取请求方法，判断是GET/POST请求</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="comment"># 处理GET请求，返回注册页面</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;register.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理POST请求，实现注册逻辑</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;这里实现注册逻辑&#x27;</span>)</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><h3 id="类视图使用"><a href="#类视图使用" class="headerlink" title="类视图使用"></a>类视图使用</h3><p>在Django中也可以使用类来定义一个视图，称为类视图。</p><p>使用类视图可以将视图对应的不同请求方式以类中的不同方法来区别定义。如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterView</span>(<span class="params">View</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;类视图：处理注册&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理GET请求，返回注册页面&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">&#x27;register.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self, request</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理POST请求，实现注册逻辑&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;这里实现注册逻辑&#x27;</span>)</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><p>类视图的好处：</p><ul><li><strong>代码可读性好</strong></li><li><strong>类视图相对于函数视图有更高的复用性</strong> ， 如果其他地方需要用到某个类视图的某个特定逻辑，直接继承该类视图即可</li></ul><p>定义类视图需要继承自Django提供的父类 <strong>View</strong>，可使用 <code>from django.views.generic import View</code> 或者<code>from django.views.generic.base import View</code> 导入，定义方式如上所示。</p><p>配置路由时，使用类视图的 <code>as_view()</code> 方法来添加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># 视图函数：注册</span></span><br><span class="line">    <span class="comment"># url(r&#x27;^register/$&#x27;, views.register, name=&#x27;register&#x27;),</span></span><br><span class="line">    <span class="comment"># 类视图：注册</span></span><br><span class="line">    url(<span class="string">r&#x27;^register/$&#x27;</span>, views.RegisterView.as_view(), name=<span class="string">&#x27;register&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><h4 id="类视图原理"><a href="#类视图原理" class="headerlink" title="类视图原理"></a>类视图原理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classonlymethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls, **initkwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Main entry point for a request-response process.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ...省略代码...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">view</span>(<span class="params">request, *args, **kwargs</span>):</span></span><br><span class="line">            self = cls(**initkwargs)</span><br><span class="line">            <span class="keyword">if</span> hasattr(self, <span class="string">&#x27;get&#x27;</span>) <span class="keyword">and</span> <span class="keyword">not</span> hasattr(self, <span class="string">&#x27;head&#x27;</span>):</span><br><span class="line">                self.head = self.get</span><br><span class="line">            self.request = request</span><br><span class="line">            self.args = args</span><br><span class="line">            self.kwargs = kwargs</span><br><span class="line">            <span class="comment"># 调用dispatch方法，按照不同请求方式调用不同请求方法</span></span><br><span class="line">            <span class="keyword">return</span> self.dispatch(request, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        ...省略代码...</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 返回真正的函数视图</span></span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># Try to dispatch to the right method; if a method doesn&#x27;t exist,</span></span><br><span class="line">        <span class="comment"># defer to the error handler. Also defer to the error handler if the</span></span><br><span class="line">        <span class="comment"># request method isn&#x27;t on the approved list.</span></span><br><span class="line">        <span class="keyword">if</span> request.method.lower() <span class="keyword">in</span> self.http_method_names:</span><br><span class="line">            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            handler = self.http_method_not_allowed</span><br><span class="line">        <span class="keyword">return</span> handler(request, *args, **kwargs)</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132</span></span><br></pre></td></tr></table></figure><h3 id="类视图使用装饰器"><a href="#类视图使用装饰器" class="headerlink" title="类视图使用装饰器"></a>类视图使用装饰器</h3><p>为类视图添加装饰器，可以使用三种方法。</p><p>为了理解方便，我们先来定义一个为 <strong>函数视图准备的装饰器</strong>（在设计装饰器时基本都以函数视图作为考虑的被装饰对象），及一个要被装饰的类视图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_require</span>(<span class="params">func_view</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">request，*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> func_view(request,*args,**kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">&quot;您没有登陆&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><h4 id="4-1-在URL配置中装饰"><a href="#4-1-在URL配置中装饰" class="headerlink" title="4.1 在URL配置中装饰"></a>4.1 在URL配置中装饰</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> book.views <span class="keyword">import</span> login_require</span><br><span class="line">urlpatterns = [</span><br><span class="line"></span><br><span class="line">    url(<span class="string">r&#x27;^center/$&#x27;</span>,login_require(CenterView.as_view()),name=<span class="string">&#x27;center&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>此种方式最简单，但因装饰行为被放置到了url配置中，单看视图的时候无法知道此视图还被添加了装饰器，不利于代码的完整性，不建议使用。</p><p><strong>此种方式会为类视图中的所有请求方法都加上装饰器行为</strong>（因为是在视图入口处，分发请求方式前）。</p><h4 id="4-2-在类视图中装饰"><a href="#4-2-在类视图中装饰" class="headerlink" title="4.2 在类视图中装饰"></a>4.2 在类视图中装饰</h4><p>在类视图中使用为函数视图准备的装饰器时，不能直接添加装饰器，需要使用 <code>method_decorator</code> 将其转换为适用于类视图的装饰器。</p><p><strong>methoddecorator装饰器还支持使用name参数指明被装饰的方法</strong>。method_decorator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@method_decorator(login_require,name=&#x27;dispatch&#x27;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span>(<span class="params">View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h4 id="4-3-构造Mixin扩展类"><a href="#4-3-构造Mixin扩展类" class="headerlink" title="4.3 构造Mixin扩展类"></a>4.3 构造Mixin扩展类</h4><p>使用面向对象多继承的特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRequireMixin</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">as_view</span>(<span class="params">cls,**kwargs</span>):</span></span><br><span class="line">        view = super().as_view(**kwargs)</span><br><span class="line">        view = login_require(view)</span><br><span class="line">        <span class="keyword">return</span> view</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterView</span>(<span class="params">LoginRequireMixin,View</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">self,request</span>):</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure><p><strong>使用Mixin扩展类，也会为类视图的所有请求方法都添加装饰行为。</strong></p><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应处理过程，修改Django的输入或输出。中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮性。</p><p>我们可以使用中间件，在Django处理视图的不同阶段对输入或输出进行干预。</p><p><a href="https://docs.djangoproject.com/en/1.11/topics/http/middleware/">中间件文档： https://docs.djangoproject.com/en/1.11/topics/http/middleware/</a></p><h4 id="1-中间件的定义方法"><a href="#1-中间件的定义方法" class="headerlink" title="1 中间件的定义方法"></a>1 中间件的定义方法</h4><p>定义一个中间件工厂函数，然后返回一个可以被调用的中间件。</p><p>中间件工厂函数需要接收一个可以调用的get_response对象。</p><p>返回的中间件也是一个可以被调用的对象，并且像视图一样需要接收一个request对象参数，返回一个response对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_middleware</span>(<span class="params">get_response</span>):</span></span><br><span class="line">    <span class="comment"># 此处编写的代码仅在Django第一次配置和初始化的时候执行一次。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request</span>):</span></span><br><span class="line">        <span class="comment"># 此处编写的代码会在每个请求处理视图前被调用。</span></span><br><span class="line"></span><br><span class="line">        response = get_response(request)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此处编写的代码会在每个请求处理视图之后被调用。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">12345678910111213</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如，在book应用中新建一个middleware.py文件，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware</span>(<span class="params">get_response</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;init 被调用&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;before request 被调用&#x27;</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">&#x27;after response 被调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义好中间件后，需要在settings.py 文件中添加注册中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;book.middleware.my_middleware&#x27;</span>,  <span class="comment"># 添加中间件</span></span><br><span class="line">]</span><br><span class="line"><span class="number">12345678910</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义一个视图进行测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;view 视图被调用&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果<br><img src="https://img-blog.csdnimg.cn/20200425122753290.png" alt="在这里插入图片描述"><br>注意：Django运行在调试模式下，中间件init部分有可能被调用两次。</p><h4 id="2-多个中间件的执行顺序"><a href="#2-多个中间件的执行顺序" class="headerlink" title="2 多个中间件的执行顺序"></a>2 多个中间件的执行顺序</h4><ul><li>在请求视图被处理前，中间件由上至下依次执行</li><li>在请求视图被处理后，中间件由下至上依次执行</li></ul><p><img src="https://img-blog.csdnimg.cn/20200425122825653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>示例：</p><p>定义两个中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware</span>(<span class="params">get_response</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;init 被调用&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;before request 被调用&#x27;</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">&#x27;after response 被调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_middleware2</span>(<span class="params">get_response</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;init2 被调用&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">middleware</span>(<span class="params">request</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;before request 2 被调用&#x27;</span>)</span><br><span class="line">        response = get_response(request)</span><br><span class="line">        print(<span class="string">&#x27;after response 2 被调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    <span class="keyword">return</span> middleware</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册添加两个中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">&#x27;django.middleware.security.SecurityMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions.middleware.SessionMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.common.CommonMiddleware&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,</span></span><br><span class="line">    <span class="string">&#x27;django.contrib.auth.middleware.AuthenticationMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages.middleware.MessageMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.middleware.clickjacking.XFrameOptionsMiddleware&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;users.middleware.my_middleware&#x27;</span>,  <span class="comment"># 添加</span></span><br><span class="line">    <span class="string">&#x27;users.middleware.my_middleware2&#x27;</span>,  <span class="comment"># 添加</span></span><br><span class="line">]</span><br><span class="line"><span class="number">1234567891011</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init2 被调用</span><br><span class="line">init 被调用</span><br><span class="line">before request 被调用</span><br><span class="line">before request <span class="number">2</span> 被调用</span><br><span class="line">view 视图被调用</span><br><span class="line">after response <span class="number">2</span> 被调用</span><br><span class="line">after response 被调用</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure><h4 id="django中间件的5个方法"><a href="#django中间件的5个方法" class="headerlink" title="django中间件的5个方法"></a>django中间件的5个方法</h4><ol><li>process_request : 请求进来时,权限认证 。</li><li>process_view : 路由匹配之后,能够得到视图函数</li><li>process_exception : 异常时执行</li><li>process_template_responseprocess : 模板渲染时执行</li><li>process_response : 请求有响应时执行</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;类视图&quot;&gt;&lt;a href=&quot;#类视图&quot; class=&quot;headerlink&quot; title=&quot;类视图&quot;&gt;&lt;/a&gt;类视图&lt;/h3&gt;&lt;p&gt;思考：一个视图，是否可以处理两种逻辑？比如get和post请求逻辑。&lt;/p&gt;
&lt;h4 id=&quot;如何在一个视图中处理get和post请</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django 状态保持 Cookie 和 Session</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/06/12/Django%20%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%20Cookie%20%E5%92%8C%20Session/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/06/12/Django%20%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81%20Cookie%20%E5%92%8C%20Session/</id>
    <published>2020-06-12T14:44:54.000Z</published>
    <updated>2020-09-13T08:45:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h3><ul><li><p>浏览器请求服务器是无状态的。</p></li><li><p>无状态：指一次用户请求时，浏览器、服务器无法知道之前这个用户做过什么，每次请求都是一次新的请求。</p></li><li><p>无状态原因：浏览器与服务器是使用Socket套接字进行通信的，服务器将请求结果返回给浏览器之后，会关闭当前的Socket连接，而且服务器也会在处理页面完毕之后销毁页面对象。</p></li><li><p>有时需要保持下来用户浏览的状态，比如用户是否登录过，浏览过哪些商品等</p></li><li><p>实现状态保持主要有两种方式：</p><p>在客户端存储信息使用<code>Cookie</code><br>在服务器端存储信息使用<code>Session</code></p></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie，有时也用其复数形式Cookies，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。Cookie最早是网景公司的前雇员Lou Montulli在1993年3月的发明。Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等。服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型记住用户名。</p><p>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</p><h4 id="Cookie的特点"><a href="#Cookie的特点" class="headerlink" title="Cookie的特点"></a>Cookie的特点</h4><ul><li>Cookie以键值对的格式进行信息的存储。</li><li>Cookie基于域名安全，不同域名的Cookie是不能互相访问的，如访问itcast.cn时向浏览器中写了Cookie信息，使用同一浏览器访问baidu.com时，无法访问到itcast.cn写的Cookie信息。</li><li>当浏览器请求某网站时，会将浏览器存储的跟网站相关的所有Cookie信息提交给网站服务器。</li></ul><h4 id="1-设置Cookie"><a href="#1-设置Cookie" class="headerlink" title="1 设置Cookie"></a>1 设置Cookie</h4><p>可以通过<code>HttpResponse</code>对象中的<code>set_cookie</code>方法来设置cookie。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse.set_cookie(cookie名, value=cookie值, max_age=cookie有效期)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><code>max_age</code>单位为秒，默认为<code>None</code> 。如果是临时cookie，可将max_age设置为None。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookie</span>(<span class="params">request</span>):</span></span><br><span class="line">    response = HttpResponse(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">    response.set_cookie(<span class="string">&#x27;itcast1&#x27;</span>, <span class="string">&#x27;python1&#x27;</span>)  <span class="comment"># 临时cookie</span></span><br><span class="line">    response.set_cookie(<span class="string">&#x27;itcast2&#x27;</span>, <span class="string">&#x27;python2&#x27;</span>, max_age=<span class="number">3600</span>)  <span class="comment"># 有效期一小时</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h4 id="2-读取Cookie"><a href="#2-读取Cookie" class="headerlink" title="2 读取Cookie"></a>2 读取Cookie</h4><p>可以通过 <code>HttpResponse</code> 对象的 <code>COOKIES</code> 属性来读取本次请求携带的 <code>cookie</code> 值。<code>request.COOKIES为字典类型</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cookie</span>(<span class="params">request</span>):</span></span><br><span class="line">    cookie1 = request.COOKIES.get(<span class="string">&#x27;itcast1&#x27;</span>)</span><br><span class="line">    print(cookie1)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h4 id="3-删除Cookie"><a href="#3-删除Cookie" class="headerlink" title="3 删除Cookie"></a>3 删除Cookie</h4><p>可以通过 <code>HttpResponse</code> 对象中的delete_cookie方法来删除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.delete_cookie(<span class="string">&#x27;itcast2&#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><h4 id="1-启用Session"><a href="#1-启用Session" class="headerlink" title="1 启用Session"></a>1 启用Session</h4><p>Django项目默认启用Session。</p><p>可以在settings.py文件中查看，如图所示</p><p><img src="https://img-blog.csdnimg.cn/20200424201023791.png" alt="在这里插入图片描述"><br>如需禁用session，将上图中的session中间件注释掉即可。</p><h4 id="2-存储方式"><a href="#2-存储方式" class="headerlink" title="2 存储方式"></a>2 存储方式</h4><p>在settings.py文件中，可以设置session数据的存储方式，可以保存在数据库、本地缓存等。</p><h5 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h5><p>存储在数据库中，如下设置可以写，也可以不写，这是<strong>默认存储方式</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SESSION_ENGINE=<span class="string">&#x27;django.contrib.sessions.backends.db&#x27;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果存储在数据库中，需要在项INSTALLED_APPS中安装Session应用。<br><img src="https://img-blog.csdnimg.cn/20200424201114649.png" alt="在这里插入图片描述"></p><p>数据库中的表如图所示</p><p><img src="https://img-blog.csdnimg.cn/20200424201129576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>表结构如下<br><img src="https://img-blog.csdnimg.cn/20200424201145337.png" alt="在这里插入图片描述"><br>由表结构可知，操作Session包括三个数据：键，值，过期时间。</p><h5 id="2-2-本地缓存"><a href="#2-2-本地缓存" class="headerlink" title="2.2 本地缓存"></a>2.2 本地缓存</h5><p>存储在本机内存中，如果丢失则不能找回，比数据库的方式读写更快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SESSION_ENGINE=<span class="string">&#x27;django.contrib.sessions.backends.cache&#x27;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-3-混合存储"><a href="#2-3-混合存储" class="headerlink" title="2.3 混合存储"></a>2.3 混合存储</h5><p>优先从本机内存中存取，如果没有则从数据库中存取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SESSION_ENGINE=<span class="string">&#x27;django.contrib.sessions.backends.cached_db&#x27;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-4-Redis"><a href="#2-4-Redis" class="headerlink" title="2.4 Redis"></a>2.4 Redis</h5><p>在redis中保存session，需要引入第三方扩展，我们可以使用django-redis来解决。</p><ul><li><p>1） 安装扩展</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install django-redis</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>2）配置</p><p>在settings.py文件中做如下设置</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CACHES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;BACKEND&#x27;</span>: <span class="string">&#x27;django_redis.cache.RedisCache&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;LOCATION&#x27;</span>: <span class="string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;OPTIONS&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;CLIENT_CLASS&#x27;</span>: <span class="string">&#x27;django_redis.client.DefaultClient&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SESSION_ENGINE = <span class="string">&#x27;django.contrib.sessions.backends.cache&#x27;</span></span><br><span class="line">SESSION_CACHE_ALIAS = <span class="string">&#x27;default&#x27;</span></span><br><span class="line"><span class="number">1234567891011</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>如果redis的ip地址不是本地回环127.0.0.1，而是其他地址，访问Django时，可能出现Redis连接错误，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200424201314867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解决方法：</p><p>修改redis的配置文件，添加特定ip地址。</p><p>打开redis的配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/redis/redis.conf</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在如下配置项进行修改（如要添加10.211.55.5地址）</p><p><img src="https://img-blog.csdnimg.cn/20200424201341157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>重新启动redis服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo service redis-server restart</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-Session操作"><a href="#3-Session操作" class="headerlink" title="3 Session操作"></a>3 Session操作</h4><p>通过HttpRequest对象的session属性进行会话的读写操作。</p><ul><li>1） 以键值对的格式写session。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.session[<span class="string">&#x27;键&#x27;</span>]=值</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>2）根据键读取值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.session.get(<span class="string">&#x27;键&#x27;</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>3）清除所有session，在存储中删除值部分。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.session.clear()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>4）清除session数据，在存储中删除session的整条数据。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.session.flush()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>5）删除session中的指定键及值，在存储中只删除某个键及对应的值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> request.session[<span class="string">&#x27;键&#x27;</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>6）设置session的有效期</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">request.session.set_expiry(value)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>如果value是一个整数，session将在value秒没有活动后过期。</li><li>如果value为0，那么用户session的Cookie将在用户的浏览器关闭时过期。</li><li>如果value为None，那么session有效期将采用系统默认值，<code>默认为两周</code>，可以通过在settings.py中设置<code>SESSION_COOKIE_AGE</code>来设置全局默认值。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;状态保持&quot;&gt;&lt;a href=&quot;#状态保持&quot; class=&quot;headerlink&quot; title=&quot;状态保持&quot;&gt;&lt;/a&gt;状态保持&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器请求服务器是无状态的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无状态：指一次用户请求时，浏览器、服务器无</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django HTTP Request对象 和 HTTP Response 对象</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/06/04/Django%20HTTP%20Request%E5%AF%B9%E8%B1%A1%20%E5%92%8C%20HTTP%20Response%20%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/06/04/Django%20HTTP%20Request%E5%AF%B9%E8%B1%A1%20%E5%92%8C%20HTTP%20Response%20%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-06-04T05:12:55.000Z</published>
    <updated>2020-09-13T08:40:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HttpRequest对象"><a href="#HttpRequest对象" class="headerlink" title="HttpRequest对象"></a>HttpRequest对象</h3><p>回想一下，利用HTTP协议向服务器传参有几种途径？</p><ul><li>提取URL的特定部分，如/weather/beijing/2018，可以在服务器端的路由中用正则表达式截取；</li><li>查询字符串（query string)，形如key1=value1&amp;key2=value2；</li><li>请求体（body）中发送的数据，比如表单数据、json、xml；</li><li>在http报文的头（header）中。</li></ul><h3 id="1-URL路径参数"><a href="#1-URL路径参数" class="headerlink" title="1 URL路径参数"></a>1 URL路径参数</h3><ul><li><p>如果想从URL中获取值，需要在正则表达式中使用分组，</p></li><li><p>获取值分为两种方式</p><ul><li>位置参数<br>参数的位置不能错</li><li>关键字参数<br>参数的位置可以变，跟关键字保持一致即可</li></ul></li><li><p>注意：两种参数的方式不要混合使用，在一个正则表达式中只能使用一种参数方式</p></li><li><p>分别使用以上两种获取URL值的方式提取出<code>18 188</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/<span class="number">18</span>/<span class="number">188</span>/</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><ul><li><p>应用中urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^(\d+)/(\d+)/$&#x27;</span>, views.index),</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>视图中函数: 参数的位置不能错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request, value1, value2</span>):</span></span><br><span class="line"><span class="comment"># 构造上下文</span></span><br><span class="line">context = &#123;<span class="string">&#x27;v1&#x27;</span>:value1, <span class="string">&#x27;v2&#x27;</span>:value2&#125;</span><br><span class="line"><span class="keyword">return</span> render(request, <span class="string">&#x27;Book/index.html&#x27;</span>, context)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><ul><li><p>应用中urls.py</p><p>其中 <code>?P</code> 部分表示为这个参数定义的名称为value1<br>可以是其它名称，起名要做到见名知意</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^(?P&lt;value1&gt;\d+)/(?P&lt;value2&gt;\d+)/$&#x27;</span>, views.index),</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>视图中函数: 参数的位置可以变，跟关键字保持一致即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request, value2, value1</span>):</span></span><br><span class="line">       <span class="comment"># 构造上下文</span></span><br><span class="line">    context = &#123;<span class="string">&#x27;v1&#x27;</span>:value1, <span class="string">&#x27;v2&#x27;</span>:value2&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;Book/index.html&#x27;</span>, context)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Django中的QueryDict对象"><a href="#2-Django中的QueryDict对象" class="headerlink" title="2 Django中的QueryDict对象"></a>2 Django中的QueryDict对象</h3><p>HttpRequest对象的属性GET、POST都是QueryDict类型的对象</p><p>与python字典不同，QueryDict类型的对象用来处理同一个键带有多个值的情况</p><ul><li><p>方法get()：根据键获取值</p><p>如果一个键同时拥有多个值将获取最后一个值</p><p>如果键不存在则返回None值，可以设置默认值进行后续处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get(<span class="string">&#x27;键&#x27;</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>方法getlist()：根据键获取值，值以列表返回，可以获取指定键的所有值</p><p>如果键不存在则返回空列表[]，可以设置默认值进行后续处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getlist(<span class="string">&#x27;键&#x27;</span>,默认值)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-查询字符串Query-String"><a href="#3-查询字符串Query-String" class="headerlink" title="3. 查询字符串Query String"></a>3. 查询字符串Query String</h3><p>获取请求路径中的查询字符串参数（形如?k1=v1&amp;k2=v2），可以通过request.GET属性获取，返回QueryDict对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /get/?a=1&amp;b=2&amp;a=3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">request</span>):</span></span><br><span class="line">    a = request.GET.get(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = request.GET.get(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    alist = request.GET.getlist(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    print(a)  <span class="comment"># 3</span></span><br><span class="line">    print(b)  <span class="comment"># 2</span></span><br><span class="line">    print(alist)  <span class="comment"># [&#x27;1&#x27;, &#x27;3&#x27;]</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">12345678910</span></span><br><span class="line">重要：查询字符串不区分请求方式，即假使客户端进行POST方式的请求，依然可以通过request.GET获取请求中的查询字符串数据。</span><br></pre></td></tr></table></figure><h3 id="4-请求体"><a href="#4-请求体" class="headerlink" title="4 请求体"></a>4 请求体</h3><p>请求体数据格式不固定，可以是表单类型字符串，可以是<code>JSON</code>字符串，可以是<code>XML</code>字符串，应区别对待。</p><p>可以发送请求体数据的请求方式有 <code>POST、PUT、PATCH、DELETE</code>。</p><p><code>Django默认开启了CSRF防护</code>，会对上述请求方式进行CSRF防护验证，在测试时可以关闭CSRF防护机制，方法为在settings.py文件中注释掉CSRF中间件，如：<br><img src="https://img-blog.csdnimg.cn/20200424150124899.png" alt="在这里插入图片描述"></p><h4 id="4-1-表单类型-Form-Data"><a href="#4-1-表单类型-Form-Data" class="headerlink" title="4.1 表单类型 Form Data"></a>4.1 表单类型 Form Data</h4><p>前端发送的表单类型的请求体数据，可以通过request.POST属性获取，返回QueryDict对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span>(<span class="params">request</span>):</span></span><br><span class="line">    a = request.POST.get(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    b = request.POST.get(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    alist = request.POST.getlist(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(alist)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-2-非表单类型-Non-Form-Data"><a href="#4-2-非表单类型-Non-Form-Data" class="headerlink" title="4.2 非表单类型 Non-Form Data"></a>4.2 非表单类型 Non-Form Data</h4><p>非表单类型的请求体数据，Django无法自动解析，可以通过request.body属性获取最原始的请求体数据，自己按照请求体格式（JSON、XML等）进行解析。request.body返回bytes类型。</p><p>例如要获取请求体中的如下JSON数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以进行如下方法操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_json</span>(<span class="params">request</span>):</span></span><br><span class="line">    json_str = request.body</span><br><span class="line">    json_str = json_str.decode()  <span class="comment"># python3.6 无需执行此步</span></span><br><span class="line">    req_data = json.loads(json_str)</span><br><span class="line">    print(req_data[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">    print(req_data[<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-请求头"><a href="#5-请求头" class="headerlink" title="5 请求头"></a>5 请求头</h3><p>可以通过request.META属性获取请求头headers中的数据，request.META为字典类型。</p><p>常见的请求头如：</p><ul><li>CONTENT_LENGTH– The length of the request body (as a string).</li><li>CONTENT_TYPE– The MIME type of the request body.</li><li>HTTP_ACCEPT– Acceptable content types for the response.</li><li>HTTP_ACCEPT_ENCODING– Acceptable encodings for the response.</li><li>HTTP_ACCEPT_LANGUAGE– Acceptable languages for the response.</li><li>HTTP_HOST– The HTTP Host header sent by the client.</li><li>HTTP_REFERER– The referring page, if any.</li><li>HTTP_USER_AGENT– The client’s user-agent string.</li><li>QUERY_STRING– The query string, as a single (unparsed) string.</li><li>REMOTE_ADDR– The IP address of the client.</li><li>REMOTE_HOST– The hostname of the client.</li><li>REMOTE_USER– The user authenticated by the Web server, if any.</li><li>REQUEST_METHOD– A string such as”GET”or”POST”.</li><li>SERVER_NAME– The hostname of the server.</li><li>SERVER_PORT– The port of the server (as a string).</li></ul><p>具体使用如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_headers</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(request.META[<span class="string">&#x27;CONTENT_TYPE&#x27;</span>])</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-其他常用HttpRequest对象属性"><a href="#6-其他常用HttpRequest对象属性" class="headerlink" title="6 其他常用HttpRequest对象属性"></a>6 其他常用HttpRequest对象属性</h3><ul><li><p>method：一个字符串，表示请求使用的HTTP方法，常用值包括：‘GET’、‘POST’。</p></li><li><p>user：请求的用户对象。</p></li><li><p>path：一个字符串，表示请求的页面的完整路径，不包含域名和参数部分。</p></li><li><p>encoding：一个字符串，表示提交的数据的编码方式。</p><p>如果为None则表示使用浏览器的默认设置，一般为utf-8。<br>这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的encoding值。</p></li><li><p>FILES：一个类似于字典的对象，包含所有的上传文件。</p></li></ul><hr><h3 id="HttpResponse对象"><a href="#HttpResponse对象" class="headerlink" title="HttpResponse对象"></a>HttpResponse对象</h3><p>视图在接收请求并处理后，必须返回HttpResponse对象或子对象。HttpRequest对象由Django创建，HttpResponse对象由开发人员创建。</p><h4 id="1-HttpResponse"><a href="#1-HttpResponse" class="headerlink" title="1 HttpResponse"></a>1 HttpResponse</h4><p>可以使用 <code>django.http.HttpResponse</code> 来构造响应对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse(content=响应体, content_type=响应体数据类型, status=状态码)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可通过HttpResponse对象属性来设置响应体、响应体数据类型、状态码：</p><ul><li>content：表示返回的内容。</li><li>status_code：返回的HTTP响应状态码。</li><li>content_type：指定返回数据的的MIME类型。</li></ul><p>响应头可以直接将HttpResponse对象当做字典进行响应头键值对的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response = HttpResponse()</span><br><span class="line">response[<span class="string">&#x27;itcast&#x27;</span>] = <span class="string">&#x27;Python&#x27;</span>  <span class="comment"># 自定义响应头Itcast, 值为Python</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;itcast python&#x27;</span>, status=<span class="number">400</span>)</span><br><span class="line">    或者</span><br><span class="line">    response = HttpResponse(<span class="string">&#x27;itcast python&#x27;</span>)</span><br><span class="line">    response.status_code = <span class="number">400</span></span><br><span class="line">    response[<span class="string">&#x27;itcast&#x27;</span>] = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"><span class="number">123456789</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-HttpResponse子类"><a href="#2-HttpResponse子类" class="headerlink" title="2 HttpResponse子类"></a>2 HttpResponse子类</h4><p>Django提供了一系列HttpResponse的子类，可以快速设置状态码</p><ul><li>HttpResponseRedirect 301</li><li>HttpResponsePermanentRedirect 302</li><li>HttpResponseNotModified 304</li><li>HttpResponseBadRequest 400</li><li>HttpResponseNotFound 404</li><li>HttpResponseForbidden 403</li><li>HttpResponseNotAllowed 405</li><li>HttpResponseGone 410</li><li>HttpResponseServerError 500</li></ul><h4 id="3-JsonResponse"><a href="#3-JsonResponse" class="headerlink" title="3 JsonResponse"></a>3 JsonResponse</h4><p>若要返回json数据，可以使用JsonResponse来构造响应对象，作用：</p><ul><li>帮助我们将数据转换为json字符串</li><li>设置响应头Content-Type为application/json</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;beijing&#x27;</span>, <span class="string">&#x27;subject&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;)</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><h4 id="4-redirect重定向"><a href="#4-redirect重定向" class="headerlink" title="4 redirect重定向"></a>4 redirect重定向</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">response</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">&#x27;/get_header&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HttpRequest对象&quot;&gt;&lt;a href=&quot;#HttpRequest对象&quot; class=&quot;headerlink&quot; title=&quot;HttpRequest对象&quot;&gt;&lt;/a&gt;HttpRequest对象&lt;/h3&gt;&lt;p&gt;回想一下，利用HTTP协议向服务器传参有几种途径？&lt;</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django URLconf，路由命名与reverse反解析（逆向）</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/06/01/Django%20URLconf%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%91%BD%E5%90%8D%E4%B8%8Ereverse%E5%8F%8D%E8%A7%A3%E6%9E%90%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/06/01/Django%20URLconf%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%91%BD%E5%90%8D%E4%B8%8Ereverse%E5%8F%8D%E8%A7%A3%E6%9E%90%EF%BC%88%E9%80%86%E5%90%91%EF%BC%89/</id>
    <published>2020-06-01T14:29:00.000Z</published>
    <updated>2020-09-13T08:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="URLconf"><a href="#URLconf" class="headerlink" title="URLconf"></a>URLconf</h3><ul><li>浏览者通过在浏览器的地址栏中输入网址请求网站</li><li>对于Django开发的网站，由哪一个视图进行处理请求，是由url匹配找到的</li></ul><h4 id="配置URLconf"><a href="#配置URLconf" class="headerlink" title="配置URLconf"></a>配置URLconf</h4><ol><li><p>settings.py中</p><p>指定url配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROOT_URLCONF = <span class="string">&#x27;项目.urls&#x27;</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>项目中urls.py</p><p>匹配成功后，包含到应用的urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(正则, include(<span class="string">&#x27;应用.urls&#x27;</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>应用中urls.py</p><p>匹配成功后，调用views.py对应的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(正则, views.函数名)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 正则部分推荐使用 r，表示字符串不转义，这样在正则</span><br><span class="line">表达式中使用 \ 只写一个就可以</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 不能在开始加反斜杠，推荐在结束加反斜杠</span><br><span class="line">    正确：path/</span><br><span class="line">    正确：path</span><br><span class="line">    错误：/path</span><br><span class="line">    错误：/path/</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 请求的url被看做是一个普通的python字符串，进行匹配时不包括域名、get或post参数</span><br><span class="line">    <span class="number">3.1</span> 如请求地址如下：</span><br><span class="line">        http://127.0.0.1:8000/18/?a=10</span><br><span class="line">    <span class="number">3.2</span> 去掉域名和参数部分后，只剩下如下部分与正则匹配</span><br><span class="line">        <span class="number">18</span>/</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="路由命名与reverse反解析（逆向）"><a href="#路由命名与reverse反解析（逆向）" class="headerlink" title="路由命名与reverse反解析（逆向）"></a>路由命名与reverse反解析（逆向）</h3><h4 id="1-路由命名"><a href="#1-路由命名" class="headerlink" title="1. 路由命名"></a>1. 路由命名</h4><p>在定义路由的时候，可以为路由命名，方便查找特定视图的具体路径信息。</p><ul><li><p>在使用include函数定义路由时，可以使用namespace参数定义路由的命名空间，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r&#x27;^&#x27;</span>,include(<span class="string">&#x27;book.urls&#x27;</span>,namespace=<span class="string">&#x27;book&#x27;</span>))</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>命名空间表示，凡是book.urls中定义的路由，均属于namespace指明的book名下。<code>命名空间的作用：避免不同应用中的路由使用了相同的名字发生冲突，使用命名空间区别开。</code></p></li><li><p>在定义普通路由时，可以使用name参数指明路由的名字，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r&#x27;^$&#x27;</span>,index),</span><br><span class="line">    <span class="comment"># 匹配书籍列表信息的URL,调用对应的bookList视图</span></span><br><span class="line">    url(<span class="string">r&#x27;^booklist/$&#x27;</span>,bookList,name=<span class="string">&#x27;index&#x27;</span>),</span><br><span class="line">    url(<span class="string">r&#x27;^testproject/$&#x27;</span>,views.testproject,name=<span class="string">&#x27;test&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-reverse反解析"><a href="#2-reverse反解析" class="headerlink" title="2. reverse反解析"></a>2. reverse反解析</h4><p>使用reverse函数，可以根据路由名称，返回具体的路径，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testproject</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;OK&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义视图：提供书籍列表信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bookList</span>(<span class="params">request</span>):</span></span><br><span class="line"></span><br><span class="line">    url = reverse(<span class="string">&#x27;book:test&#x27;</span>)</span><br><span class="line">    print(url)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><ul><li>对于未指明namespace的，reverse(路由name)</li><li>对于指明namespace的，reverse(命名空间namespace:路由name)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;URLconf&quot;&gt;&lt;a href=&quot;#URLconf&quot; class=&quot;headerlink&quot; title=&quot;URLconf&quot;&gt;&lt;/a&gt;URLconf&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;浏览者通过在浏览器的地址栏中输入网址请求网站&lt;/li&gt;
&lt;li&gt;对于Django开发的网</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Django 视图介绍</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2020/05/26/Django%20%E8%A7%86%E5%9B%BE%E4%BB%8B%E7%BB%8D/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2020/05/26/Django%20%E8%A7%86%E5%9B%BE%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-26T13:03:44.000Z</published>
    <updated>2020-09-13T08:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="视图介绍和项目准备"><a href="#视图介绍和项目准备" class="headerlink" title="视图介绍和项目准备"></a>视图介绍和项目准备</h3><p><img src="https://img-blog.csdnimg.cn/20200424131358536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>视图介绍</p><ul><li>视图就是应用中views.py文件中的函数</li><li>视图的第一个参数必须为HttpRequest对象，还可能包含下参数如<br>通过正则表达式组获取的位置参数<br>通过正则表达式组获得的关键字参数</li><li>视图必须返回一个HttpResponse对象或子对象作为响应<br>子对象： JsonResponse HttpResponseRedirect</li><li>视图负责接受Web请求HttpRequest，进行逻辑处理，返回Web响应HttpResponse给请求者<br>响应内容可以是HTML内容，404错误，重定向，json数据…</li><li>视图处理过程如下图：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200424131510587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY4NTg2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>使用视图时需要进行两步操作，两步操作不分先后</p><ul><li>配置URLconf</li><li>在应用/views.py中定义视图</li></ul><p>详细操作：<a href="https://blog.csdn.net/weixin_44685869/article/details/105353646">视图和URL: https://blog.csdn.net/weixin_44685869/article/details/105353646</a></p><h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><p>项目准备整体流程：<a href="https://blog.csdn.net/weixin_44685869/article/details/105362452">https://blog.csdn.net/weixin_44685869/article/details/105362452</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;视图介绍和项目准备&quot;&gt;&lt;a href=&quot;#视图介绍和项目准备&quot; class=&quot;headerlink&quot; title=&quot;视图介绍和项目准备&quot;&gt;&lt;/a&gt;视图介绍和项目准备&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020</summary>
      
    
    
    
    <category term="djangobook" scheme="https://github.com/xuMr6/xumr6.github.io.git/categories/djangobook/"/>
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
</feed>
