<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XuMr</title>
  
  
  <link href="https://github.com/xuMr6/xumr6.github.io.git/atom.xml" rel="self"/>
  
  <link href="https://github.com/xuMr6/xumr6.github.io.git/"/>
  <updated>2020-09-03T13:31:05.407Z</updated>
  <id>https://github.com/xuMr6/xumr6.github.io.git/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络协议http与https,tcp和udp,tcp/ip</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2018/02/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEhttp%E4%B8%8Ehttps,tcp%E5%92%8Cudp,tcp/ip/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2018/02/19/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEhttp%E4%B8%8Ehttps,tcp%E5%92%8Cudp,tcp/ip/</id>
    <published>2018-02-18T17:45:18.000Z</published>
    <updated>2020-09-03T13:31:05.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP和HTTPS是什么？"><a href="#HTTP和HTTPS是什么？" class="headerlink" title="HTTP和HTTPS是什么？"></a>HTTP和HTTPS是什么？</h1><p>我们使用浏览器访问一个网站页面，在浏览器的地址栏中我们会看到一串URL，如图<br><img src="https://img-blog.csdnimg.cn/20200730105900432.png" alt="在这里插入图片描述"><br>网站的URL会分为两部分：通信协议和域名地址。</p><p>域名地址都很好理解，不同的域名地址表示网站中不同的页面，而通信协议，简单来说就是浏览器和服务器之间沟通的语言。网站中的通信协议一般就是HTTP协议和HTTPS协议。</p><p>HTTP协议</p><p>HTTP协议是一种使用明文数据传输的网络协议。一直以来HTTP协议都是最主流的网页协议，但是互联网发展到今天，HTTP协议的明文传输会让用户存在一个非常大的安全隐患。试想一下，假如你在一个HTTP协议的网站上面购物，你需要在页面上输入你的银行卡号和密码，然后你把数据提交到服务器实现购买。假如这个适合，你的传输数据被第三者给截获了，由于HTTP明文数据传输的原因，你的银行卡号和密码，将会被这个截获人所得到。现在你还敢在一个HTTP的网站上面购物吗？你还会在一个HTTP的网站上面留下你的个人信息吗？<br><img src="https://img-blog.csdnimg.cn/20200730105912831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>HTTPS协议</p><p>HTTPS协议可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息让然是安全的。这就是HTTP和HTTPS的最大区别。<br><img src="https://img-blog.csdnimg.cn/20200730105929243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>其实如果你足够细心，你会发现现在很多大型互联网网站，如百度、淘宝、腾讯很早就已经把HTTP换成HTTPS了。<br><img src="https://img-blog.csdnimg.cn/20200730105938604.png" alt="在这里插入图片描述"></p><p>HTTP和HTTPS的其他不同</p><p>数据加密传输，是HTTP和HTTPS之间的本质性区别，其实除了这个之外，HTTPS网站和HTTP网站还有其他地方不同。</p><p>当你使用Chrome浏览器访问一个HTTP网站的时候，你会发现浏览器会对该HTTP网站显示“不安全”的安全警告，提示用户当前所访问的网站可能会存在风险。<br><img src="https://img-blog.csdnimg.cn/20200730105949107.png" alt="在这里插入图片描述"><br>而假如你访问的是一个HTTPS网站时，情况却是完全不一样。你会发现浏览器的地址栏会变成绿色，企业名称会展示在地址栏中，地址栏上面还会出现一把“安全锁”的图标。这些都会给与用户很大的视觉上的安全体验。以下是EV证书在不同浏览器中的展现。<br><img src="https://img-blog.csdnimg.cn/20200730110006419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>除了浏览器视觉上不同以外，HTTPS网站和HTTP网站还有一个很重要的区别，就是对搜索排名的提升，这也是很多站长所关注的地方。</p><p>百度和谷歌两大搜索引擎都已经明确表示，HTTPS网站将会作为搜索排名的一个重要权重指标。也就是说HTTPS网站比起HTTP网站在搜索排名中更有优势。</p><p>HTTPS网站相比起HTTP网站拥有着多种的优势，HTTP明显已经不能适应当今这个互联网时代，可以预见到HTTP在不久的将来将会全面被HTTPS所取代。</p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)同步：端口下如果同是来了两个客户端请求，第一个连接得到响应，与服务端建立通讯，而第二个请求就会被一直阻塞直到第一个请求完成操作，各请求之间排队，顺序执行。</span><br><span class="line">　(2)异步呢，就是同时来两个或者多个请求，服务端就同时响应多个客户端，同时给他们连接。各个客户端与服务器的通讯是并行的，一个客户端不必等另一个客户端完成操作。通常用这两个方法来接收一个客户端请求。</span><br><span class="line">　(3)阻塞 调用是指调用结果返回之前，当前线程会被挂起。比如：Console.ReadLine(),如果你不向控制台输入数据，这个方法就会一直等待，知道你输入数据后才会向下执行。这个时候当前线程被挂起来了，让CPU去做其他事情。</span><br><span class="line">　(4)非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</span><br></pre></td></tr></table></figure><h3 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.</span><br><span class="line">Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</span><br><span class="line">Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击</span><br><span class="line">netstat -n -p TCP | grep SYN_RECV</span><br><span class="line">一般较新的TCP&#x2F;IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.</span><br><span class="line">但是不能完全防范syn攻击。</span><br></pre></td></tr></table></figure><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于广播提供面向无连接的通信服务</p><p>握手<br>“我想给你发数据，可以吗？” （请提供序列号作为起始数据段）SYN：同步序列编号（Synchronize Sequence Numbers）<br>“可以，你什么时候发？” （已提供序列号）SYN+ACK应答<br>“我现在就发，你接着吧！”  ACK消息响应</p><p>挥手 （A为主动关闭方，可以是SERVICE也可以是CLIENT）<br>SERVER：传输好了，我要关了   1 ) 当主机A完成数据传输后,发送FIN,提出停止TCP连接的请求，进入FIN_WAIT1状态<br>CLIENT：我看一下                       2 ) 主机B收到FIN后，将发送ACK，进入CLOSE_WAIT状态<br>CLIENT：OK ，可以关                 3 ) 由B 端再提出反方向的关闭请求,将发送FIN，并进入LAST_ACK状态<br>SERVER： 嗯，我关了                 4 ) 主机A对主机B的请求进行确认收到FIN,将发送ACK,双方向的关闭结束.进入TIME_WAIT状态，经过2MSL时间后关闭<br><img src="https://img-blog.csdnimg.cn/20200730111819462.png" alt="在这里插入图片描述"></p><p>UDP（User Data Protocol，用户数据报协议）<br>我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。<br>UDP应用场景： 1.面向数据报方式  2.网络数据大多为短消息   3.拥有大量Client  4.对数据安全性无特殊要求  5.网络负担非常重，但对响应速度要求高</p><p>小结TCP与UDP的区别：    1.基于连接与无连接；    2.对系统资源的要求（TCP较多，UDP少）；    3.UDP程序结构较简单；    4.流模式与数据报模式 ；    5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">TCP: </span><br><span class="line">TCP编程的服务器端一般步骤是： TCP包头的最小长度，为20字节。</span><br><span class="line">　　1、创建一个socket，用函数socket()； </span><br><span class="line">　　2、设置socket属性，用函数setsockopt(); * 可选 </span><br><span class="line">　　3、绑定IP地址、端口等信息到socket上，用函数bind(); </span><br><span class="line">　　4、开启监听，用函数listen()； </span><br><span class="line">　　5、接收客户端上来的连接，用函数accept()； </span><br><span class="line">　　6、收发数据，用函数send()和recv()，或者read()和write(); </span><br><span class="line">　　7、关闭网络连接； </span><br><span class="line">　　8、关闭监听； </span><br><span class="line">TCP编程的客户端一般步骤是： </span><br><span class="line">　　1、创建一个socket，用函数socket()； </span><br><span class="line">　　2、设置socket属性，用函数setsockopt();* 可选 </span><br><span class="line">　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </span><br><span class="line">　　4、设置要连接的对方的IP地址和端口等属性； </span><br><span class="line">　　5、连接服务器，用函数connect()； </span><br><span class="line">　　6、收发数据，用函数send()和recv()，或者read()和write(); </span><br><span class="line">　　7、关闭网络连接；</span><br><span class="line"></span><br><span class="line">UDP:与之对应的UDP编程步骤要简单许多，分别如下： </span><br><span class="line">UDP编程的服务器端一般步骤是： </span><br><span class="line">　　1、创建一个socket，用函数socket()； </span><br><span class="line">　　2、设置socket属性，用函数setsockopt();* 可选 </span><br><span class="line">　　3、绑定IP地址、端口等信息到socket上，用函数bind(); </span><br><span class="line">　　4、循环接收数据，用函数recvfrom(); </span><br><span class="line">　　5、关闭网络连接； </span><br><span class="line">UDP编程的客户端一般步骤是： </span><br><span class="line">　　1、创建一个socket，用函数socket()； </span><br><span class="line">　　2、设置socket属性，用函数setsockopt();* 可选 </span><br><span class="line">　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 </span><br><span class="line">　　4、设置对方的IP地址和端口等属性; </span><br><span class="line">　　5、发送数据，用函数sendto(); </span><br><span class="line">　　6、关闭网络连接；</span><br></pre></td></tr></table></figure><h1 id="为什么会有TCP-IP协议"><a href="#为什么会有TCP-IP协议" class="headerlink" title="为什么会有TCP/IP协议"></a>为什么会有TCP/IP协议</h1><p>在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法是千差万别。就好像圣经中上帝打乱了各地人的口音，让他们无法合作一样。计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。</p><p>但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。</p><p>TCP/IP模型<br><img src="https://img-blog.csdnimg.cn/20200730112605800.png" alt="在这里插入图片描述"><br>应用层:<br>向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。</p><p>传输层:<br>提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。为实现后者，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送。</p><p>网络层 ：<br>负责相邻计算机之间的通信。其功能包括三方面。<br>一、处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。</p><p>二、处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。</p><p>三、处理路径、流控、拥塞等问题。</p><p>网络接口层：<br>这是TCP/IP软件的最低层，负责接收IP数据报并通过网络发送之，或者从网络上接收物理帧，抽出IP数据报，交给IP层。</p><p>IP<br>IP 用于计算机之间的通信。</p><p>IP 是无连接的通信协议。它不会占用两个正在通信的计算机之间的通信线路。这样，IP 就降低了对网络线路的需求。每条线可以同时满足许多不同的计算机之间的通信需要。</p><p>通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。</p><p>IP 负责将每个包路由至它的目的地。</p><p>IP地址<br>每个计算机必须有一个 IP 地址才能够连入因特网。</p><p>每个 IP 包必须有一个地址才能够发送到另一台计算机。</p><p>网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。</p><p>CP/IP 使用 32 个比特来编址。一个计算机字节是 8 比特。所以 TCP/IP 使用了 4 个字节。<br>一个计算机字节可以包含 256 个不同的值：<br>00000000、00000001、00000010、00000011、00000100、00000101、00000110、00000111、00001000 … 直到 11111111。<br>现在，你知道了为什么 TCP/IP 地址是介于 0 到 255 之间的 4 个数字。</p><p>TCP 使用固定的连接<br>TCP 用于应用程序之间的通信。</p><p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信。</p><p>这个全双工的通信将占用两个计算机之间的通信线路，直到它被一方或双方关闭为止。</p><p>UDP 和 TCP 很相似，但是更简单，同时可靠性低于 TCP。</p><p>IP 路由器<br>当一个 IP 包从一台计算机被发送，它会到达一个 IP 路由器。</p><p>IP 路由器负责将这个包路由至它的目的地，直接地或者通过其他的路由器。</p><p>在一个相同的通信中，一个包所经由的路径可能会和其他的包不同。而路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址。</p><p>域名<br>12 个阿拉伯数字很难记忆。使用一个名称更容易。</p><p>用于 TCP/IP 地址的名字被称为域名。<a href="http://www.baidu.com就是一个域名./">www.baidu.com就是一个域名。</a></p><p>当你键入一个像<a href="https://www.baidu.com/%E8%BF%99%E6%A0%B7%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%9F%9F%E5%90%8D%E4%BC%9A%E8%A2%AB%E4%B8%80%E7%A7%8D">https://www.baidu.com/这样的域名，域名会被一种</a> DNS 程序翻译为数字。</p><p>在全世界，数量庞大的 DNS 服务器被连入因特网。DNS 服务器负责将域名翻译为 TCP/IP 地址，同时负责使用新的域名信息更新彼此的系统。</p><p>当一个新的域名连同其 TCP/IP 地址一同注册后，全世界的 DNS 服务器都会对此信息进行更新。</p><p>TCP/IP<br>TCP/IP 意味着 TCP 和 IP 在一起协同工作。</p><p>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。</p><p>IP 负责计算机之间的通信。</p><p>TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。</p><p>IP 负责将包发送至接受者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP和HTTPS是什么？&quot;&gt;&lt;a href=&quot;#HTTP和HTTPS是什么？&quot; class=&quot;headerlink&quot; title=&quot;HTTP和HTTPS是什么？&quot;&gt;&lt;/a&gt;HTTP和HTTPS是什么？&lt;/h1&gt;&lt;p&gt;我们使用浏览器访问一个网站页面，在浏览器的地</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python常见算法面试题</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2018/02/16/python%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2018/02/16/python%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2018-02-16T07:23:28.000Z</published>
    <updated>2020-09-03T13:40:18.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么输出6，6，6，6"><a href="#为什么输出6，6，6，6" class="headerlink" title="为什么输出6，6，6，6"></a>为什么输出6，6，6，6</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num</span>():</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">lambda</span> x: i*x <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]   <span class="comment"># 这里使用的是lambda函数 </span></span><br><span class="line">print([m(<span class="number">2</span>) <span class="keyword">for</span> m <span class="keyword">in</span> num()])     <span class="comment"># 输出: [6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这题涉及到了闭包延时绑定，当循环执行完了之后才会执行传参，循环四次，每一次循环完 i=3 然后再和x相乘 所以结果是6，6，6，6。 如果把 [ lambda x: ix for i in range(4) ] 改成 （ lambda x: ix for i in range(4) ）这样就变成了一个生成器 自动实现迭代器协议，一边循环一边计算的机制， 这样结果就是 0，2，4，6.</p><h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这里可以使用字典来解题，通过enumerate方法遍历获取数据的下标包括对应值，然后以key，value形式把该数据的下标和对应值存入字典，然后再出通过enumerate方法遍历数据，每一次获取数据就从字典拿出一个值，用目标值减去从字典拿出的这个值得到一个结果值，如果结果值存在字典当中，那么返回两个数的下标，如果为None，说明字典中没有这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_index_list</span>(<span class="params">nums, target</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Todo 作为一个方法来实现，批量解决这个获取索引的问题</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :params nums：传的参数的列表</span></span><br><span class="line"><span class="string">    :params target: 目标值</span></span><br><span class="line"><span class="string">    :return: 返回索引</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> enumerate(nums):  <span class="comment"># a是下标 b是对应值</span></span><br><span class="line"></span><br><span class="line">        dic[b] = a  <span class="comment"># 对应值存入字典</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, b <span class="keyword">in</span> enumerate(nums):</span><br><span class="line"></span><br><span class="line">        j = dic.get(target-b)  <span class="comment"># 从字典中拿出对应值 用目标值减去对应值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 判断如果减去的对应值不为空，则返回下标</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> [i, j]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(get_index_list([<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>],<span class="number">9</span>))</span><br></pre></td></tr></table></figure><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span> 或 <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><p>这道题想到的是，使用列表中的count方法，定义一个空列表，遍历数据然后进行判断，如果数据值出现个数大于或等于2，说明该数据是重复的，然后把重复的筛取出来之后存入空列表，再进行返回输出。</p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :params nums：传的参数的数组</span></span><br><span class="line"><span class="string">    :return: 返回重复数字</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    nub = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> nums.count(i) &gt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> str(i) <span class="keyword">not</span> <span class="keyword">in</span> nub:</span><br><span class="line">                nub.append(str(i))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;或&#x27;</span>.join(nub))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    get_number([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><h1 id="队列实现一个栈"><a href="#队列实现一个栈" class="headerlink" title="队列实现一个栈"></a>队列实现一个栈</h1><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><p>使用一个队列，实现栈的一些基本操作，栈（后进先出）的特性。</p><h2 id="实现代码：-1"><a href="#实现代码：-1" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 队列实现一个栈 （栈：后进先出）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>(<span class="params">object</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 定义一个队列</span></span><br><span class="line">        self.lst = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_None</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 判断栈是否为空 返回 ture false</span></span><br><span class="line">        <span class="keyword">return</span> self.lst == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, i</span>):</span></span><br><span class="line">        <span class="comment"># 加入元素</span></span><br><span class="line">        self.lst.append(i)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 出栈</span></span><br><span class="line">        <span class="keyword">return</span> self.lst.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stack_top</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 返回栈顶元素</span></span><br><span class="line">        <span class="keyword">return</span> self.lst[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 栈的大小</span></span><br><span class="line">        <span class="keyword">return</span> len(self.lst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    stack = Stack()</span><br><span class="line">    print(stack.is_None())</span><br><span class="line">    stack.push(<span class="number">1</span>)</span><br><span class="line">    stack.push(<span class="number">2</span>)</span><br><span class="line">    stack.push(<span class="number">3</span>)</span><br><span class="line">    print(stack.lst)</span><br><span class="line">    print(stack.pop())</span><br><span class="line">    print(stack.stack_top())</span><br><span class="line">    print(stack.size())</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h1 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h1><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">121</span></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">-121</span></span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右，为 <span class="number">-121</span> 。 从右向左读，为<span class="number">121</span>- 。 因此它不是一个回文数</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读，为 01 。 因此它不是一个回文数</span><br></pre></td></tr></table></figure><h2 id="思路：-3"><a href="#思路：-3" class="headerlink" title="思路："></a>思路：</h2><p>这题可以使用字符串 双指针的方法 将数据转化为字符串 首先定义好第一个元素下标和最后一个元素下标，while循环 只要条件不满足 一直循环 循环判断第一个和最后一个元素是否相等 不相等返回false 相等继续循环，如果循环条件满足之后都相等，返回 false</p><h2 id="实现代码：-2"><a href="#实现代码：-2" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromic_number</span>(<span class="params">x</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :params x：传的参数的列表</span></span><br><span class="line"><span class="string">    :return: 返回Ture False</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    lst = list(str(x))</span><br><span class="line">    print(lst)</span><br><span class="line">    L, R = <span class="number">0</span>, len(lst)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">        print(L, R)</span><br><span class="line">        <span class="keyword">if</span> lst[L] != lst[R]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        L += <span class="number">1</span></span><br><span class="line">        R -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(palindromic_number(<span class="number">1231</span>))</span><br></pre></td></tr></table></figure><hr><h1 id="分别用生成器和迭代器生成斐波那契数列"><a href="#分别用生成器和迭代器生成斐波那契数列" class="headerlink" title="分别用生成器和迭代器生成斐波那契数列"></a>分别用生成器和迭代器生成斐波那契数列</h1><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出: 1 1 2 3 5 8 13</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用迭代器生成斐波那契数列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacii</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,all_num</span>):</span></span><br><span class="line">        self.all_num = all_num</span><br><span class="line">        self.cur_idx = <span class="number">0</span></span><br><span class="line">        self.a = <span class="number">0</span>  </span><br><span class="line">        self.b = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.cur_idx &gt;= self.all_num:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        ret = self.a</span><br><span class="line">        </span><br><span class="line">        self.a, self.b = self.b, self.a + self.b</span><br><span class="line">        self.cur_idx += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line">fibo = Fibonacii(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fibo:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用生成器生成斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibnacii</span>(<span class="params">count</span>):</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num &lt; count:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fi = fibnacii(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fi:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><h1 id="反转字符数组"><a href="#反转字符数组" class="headerlink" title="反转字符数组"></a>反转字符数组</h1><h2 id="思路：-4"><a href="#思路：-4" class="headerlink" title="思路："></a>思路：</h2><p>直接使用反转</p><h2 id="实现代码：-3"><a href="#实现代码：-3" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 反转字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">s</span>):</span></span><br><span class="line">    s[<span class="number">0</span>::] = s[::<span class="number">-1</span>]</span><br><span class="line">    print(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    reverseString([<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;r&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="string">&quot;Let&#x27;s take LeetCode contest&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(a.split(<span class="string">&#x27; &#x27;</span>)[::<span class="number">-1</span>])[::<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(b())</span><br></pre></td></tr></table></figure><h1 id="球"><a href="#球" class="headerlink" title="球"></a>球</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span>():</span></span><br><span class="line">    slit=[]</span><br><span class="line">    s=<span class="number">100</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">if</span> c==<span class="number">0</span>:</span><br><span class="line">            slit.append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            slit.append(s*<span class="number">2</span>)</span><br><span class="line">        s=s/<span class="number">2</span></span><br><span class="line">    print(sum(slit))</span><br><span class="line">    print(s)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a()</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义一个函数传入个变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span>(<span class="params">li</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(li)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> li[j] &gt; li[j+<span class="number">1</span>]:</span><br><span class="line">                li[j],li[j+<span class="number">1</span>]=li[j+<span class="number">1</span>],li[j]</span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>]</span><br><span class="line">bubble_sort(li)</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;为什么输出6，6，6，6&quot;&gt;&lt;a href=&quot;#为什么输出6，6，6，6&quot; class=&quot;headerlink&quot; title=&quot;为什么输出6，6，6，6&quot;&gt;&lt;/a&gt;为什么输出6，6，6，6&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>完整的HTTP请求全过程</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2018/02/08/%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2018/02/08/%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/</id>
    <published>2018-02-08T08:56:18.000Z</published>
    <updated>2020-09-03T13:38:10.584Z</updated>
    
    <content type="html"><![CDATA[<p>一、 HTTP请求和响应步骤<br><img src="https://img-blog.csdnimg.cn/20200707121901742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以上完整表示了HTTP请求和响应的7个步骤，下面从TCP/IP协议模型的角度来理解HTTP请求和响应如何传递的。</p><p>二、TCP/IP协议<br>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。</p><p>HTTP协议就是基于TCP/IP协议模型来传输信息的。<br><img src="https://img-blog.csdnimg.cn/20200707122057109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>(1). 链路层</p><p>也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。</p><p>(2). 网络层</p><p>也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。</p><p>IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。</p><p>ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。</p><p>IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。</p><p>(3). 传输层</p><p>主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。</p><p>TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。</p><p>UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。<br>(4). 应用层</p><p>应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。<br><img src="https://img-blog.csdnimg.cn/20200707122132342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。<br><img src="https://img-blog.csdnimg.cn/20200707122150280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。</p><p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p><p>下面这张图更清楚明白：<br><img src="https://img-blog.csdnimg.cn/20200707122202995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面具体来看如何进行一步步操作的。</p><p>三、TCP三次握手<br>TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。<br> <img src="https://img-blog.csdnimg.cn/20200707122219505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</p><p>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><p>为什么要三次握手</p><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><p>四、HTTP协议<br>Http是什么？</p><p>通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。</p><p>四个基于：</p><p>请求与响应：客户端发送请求，服务器端响应数据</p><p>无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。</p><p>应用层：Http是属于应用层的协议，配合TCP/IP使用。</p><p>TCP/IP：Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。</p><p>针对无状态的一些解决策略：</p><p>有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。</p><p>HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。<br>等等还有很多。。。。。。</p><p>下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。</p><p>HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。</p><p>五、HTTP请求报文<br>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。<br><img src="https://img-blog.csdnimg.cn/20200707122239692.png" alt="在这里插入图片描述"><br>1.请求行</p><p>请求行分为三个部分：请求方法、请求地址和协议版本</p><p>请求方法</p><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><p>请求地址</p><p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p><p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt;</p><p>端口和路径有时可以省略（HTTP默认端口号是80）</p><p>如下例：<br><img src="https://img-blog.csdnimg.cn/20200707122259944.png" alt="在这里插入图片描述"><br>有时会带参数，GET请求</p><p>协议版本</p><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><p>2.请求头部</p><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><p>常见请求头如下：<br><img src="https://img-blog.csdnimg.cn/20200707122313634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><p>3.请求数据</p><p>可选部分，比如GET请求就没有请求数据。</p><p>下面是一个POST方法的请求报文：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST 　/index.php　HTTP/1.1 　　 请求行</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://localhost/</span><br><span class="line">Content-Length：25</span><br><span class="line">Content-Type：application/x-www-form-urlencoded</span><br><span class="line">　　空行</span><br><span class="line">username=aa&amp;password=1234　　请求数据</span><br></pre></td></tr></table></figure><p>六、HTTP响应报文<br><img src="https://img-blog.csdnimg.cn/20200707122335277.png" alt="在这里插入图片描述"><br>HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。</p><p>1.状态行</p><p>由3部分组成，分别为：协议版本，状态码，状态码描述。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><p>状态码</p><p>状态代码为3位数字。<br>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>下面列举几个常见的：</p><p><img src="https://img-blog.csdnimg.cn/20200707122344581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>2.响应头部</p><p>与请求头部类似，为响应报文添加了一些附加信息</p><p>常见响应头部如下：<br> <img src="https://img-blog.csdnimg.cn/20200707122410106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>3.响应数据</p><p>用于存放需要返回给客户端的数据信息。</p><p>下面是一个响应报文的实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK　　状态行</span><br><span class="line">Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部</span><br><span class="line">Server: Apache/2.2.8 (Win32) PHP/5.2.5</span><br><span class="line">X-Powered-By: PHP/5.2.5</span><br><span class="line">Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Length: 4393</span><br><span class="line">Keep-Alive: timeout=5, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">　　空行</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>　　响应数据</span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP响应示例<span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello HTTP!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于请求头部和响应头部的知识点很多，这里只是简单介绍。</p><p>通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。</p><p>七、TCP四次挥手<br>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。<br><img src="https://img-blog.csdnimg.cn/20200707122431423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</p><p>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</p><p>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><p>为什么要四次分手</p><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p><p>通过以上步骤便完成了HTTP的请求和响应，进行了数据传递，这其中涉及到需要知识点，都进行了逐一了解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、 HTTP请求和响应步骤&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200707121901742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shad</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>UWSGI和WSGI和nginx</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2018/01/29/UWSGI%E5%92%8CWSGI%E5%92%8Cnginx/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2018/01/29/UWSGI%E5%92%8CWSGI%E5%92%8Cnginx/</id>
    <published>2018-01-29T07:25:07.000Z</published>
    <updated>2020-09-03T13:28:12.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是UWSGI和WSGI"><a href="#什么是UWSGI和WSGI" class="headerlink" title="什么是UWSGI和WSGI"></a>什么是UWSGI和WSGI</h1><h1 id="uwsgi协议"><a href="#uwsgi协议" class="headerlink" title="uwsgi协议"></a>uwsgi协议</h1><p>uwsgi（小写！）协议是uWSGI服务器使用的本机协议。</p><p>它是一个二进制协议，可以携带任何类型的数据。uwsgi数据包的前4个字节描述了该数据包包含的数据的类型。</p><p><strong>每个uwsgi请求都会以uwsgi格式生成响应。</strong></p><p>甚至Web服务器处理程序也遵守此规则，因为HTTP响应是有效的uwsgi数据包（请参阅<code>modifier1</code>= 72）。</p><p>该协议主要通过TCP起作用，但是主进程可以绑定到UDP单播/多播，用于<a href="https://uwsgi-docs.readthedocs.io/en/latest/SNMP.html">嵌入式SNMP服务器</a>或群集管理/消息请求。</p><p>SCTP支持正在开发中。</p><h3 id="什么是-WSGI"><a href="#什么是-WSGI" class="headerlink" title="什么是 WSGI"></a>什么是 WSGI</h3><p>先说一下<code>CGI</code>，（通用网关接口， Common Gateway Interface/CGI），定义客户端与Web服务器的交流方式的一个程序。例如正常情况下客户端发来一个请求，根据<code>HTTP</code>协议Web服务器将请求内容解析出来，进过计算后，再将加us安出来的内容封装好，例如服务器返回一个<code>HTML</code>页面，并且根据<code>HTTP</code>协议构建返回内容的响应格式。涉及到<code>TCP</code>连接、<code>HTTP</code>原始请求和相应格式的这些，都由一个软件来完成，这时，以上的工作需要一个程序来完成，而这个程序便是<code>CGI</code>。</p><p>那什么是<code>WSGI</code>呢？<a href="https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">维基</a>上的解释为，<strong>Web服务器网关接口(Python Web Server Gateway Interface，WSGI)**，是为<code>Python</code>语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。从语义上理解，貌似<code>WSGI</code>就是<code>Python</code>为了解决</strong>Web服务器端与客户端**之间的通信问题而产生的，并且<code>WSGI</code>是基于现存的<code>CGI</code>标准而设计的，同样是一种程序（或者<code>Web</code>组件的接口规范？）。</p><p><a href="https://link.jianshu.com/?t=https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">WSGI</a>区分为两部分：一种为“服务器”或“网关”，另一种为“应用程序”或“应用框架”。<br> 所谓的<code>WSGI</code>中间件同时实现了<code>API</code>的两方，即在<code>WSGI</code>服务器和<code>WSGI</code>应用之间起调解作用：从<code>WSGI</code>服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。中间件具有的功能：</p><ul><li>重写环境变量后，根据目标URL，将请求消息路由到不同的应用对象。</li><li>允许在一个进程中同时运行多个应用程序或应用框架</li><li>负载均衡和远程处理，通过在网络上转发请求和相应消息。</li><li>进行内容后处理，例如应用<code>XSLT</code>样式表。（以上 from 维基）</li></ul><p>看了这么多，总结一下，其实可以说<code>WSGI</code>就是基于<code>Python</code>的以<code>CGI</code>为标准做一些扩展。</p><h3 id="什么是ASGI"><a href="#什么是ASGI" class="headerlink" title="什么是ASGI"></a>什么是<a href="https://link.jianshu.com/?t=https://blog.ernest.me/post/asgi-draft-spec-zh">ASGI</a></h3><p>异步网关协议接口，一个介于网络协议服务和<code>Python</code>应用之间的标准接口，能够处理多种通用的协议类型，包括<code>HTTP</code>，<code>HTTP2</code>和<code>WebSocket</code>。<br> 然而目前的常用的<code>WSGI</code>主要是针对<code>HTTP</code>风格的请求响应模型做的设计，并且越来越多的不遵循这种模式的协议逐渐成为<code>Web</code>变成的标准之一，例如<code>WebSocket</code>。<br> <code>ASGI</code>尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容<code>HTTP</code>请求响应以及<code>WebSocket</code>数据帧的序列格式。允许这些协议能通过网络或本地<code>socket</code>进行传输，以及让不同的协议被分配到不同的进程中。</p><h3 id="WSGI和ASGI的区别在哪"><a href="#WSGI和ASGI的区别在哪" class="headerlink" title="WSGI和ASGI的区别在哪"></a>WSGI和ASGI的区别在哪</h3><p>以上，<code>WSGI</code>是基于<code>HTTP</code>协议模式的，不支持<code>WebSocket</code>，而<code>ASGI</code>的诞生则是为了解决<code>Python</code>常用的<code>WSGI</code>不支持当前<code>Web</code>开发中的一些新的协议标准。同时，<code>ASGI</code>对于<code>WSGI</code>原有的模式的支持和<code>WebSocket</code>的扩展，即<code>ASGI</code>是<code>WSGI</code>的扩展。</p><h1 id="nginx的正向代理和反向代理"><a href="#nginx的正向代理和反向代理" class="headerlink" title="nginx的正向代理和反向代理"></a>nginx的正向代理和反向代理</h1><h1 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h1><p>nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。</p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>在如今的网络环境下，我们如果由于技术需要去访问国外的某些网站，此时你会发现位于国外的某些网站我们通过浏览器是没有办法访问的，此时大家都可能会用一个操作FQ进行访问，FQ的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们。这就是正向代理。正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>比如某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用nginx进行反向代理实现的，并且通过封装nginx和其他的组件之后起了一个高大上的名字：Tengine</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是UWSGI和WSGI&quot;&gt;&lt;a href=&quot;#什么是UWSGI和WSGI&quot; class=&quot;headerlink&quot; title=&quot;什么是UWSGI和WSGI&quot;&gt;&lt;/a&gt;什么是UWSGI和WSGI&lt;/h1&gt;&lt;h1 id=&quot;uwsgi协议&quot;&gt;&lt;a href=&quot;#uw</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>flask中使用原生sql语句</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2018/01/16/flask%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql%E8%AF%AD%E5%8F%A5/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2018/01/16/flask%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9Fsql%E8%AF%AD%E5%8F%A5/</id>
    <published>2018-01-16T02:16:10.000Z</published>
    <updated>2020-09-03T13:33:35.247Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说直接上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">config配置</span><br><span class="line">SQLALCHEMY_DATABASE_URI = <span class="string">&#x27;mysql+pymysql://root:6666@127.0.0.1:3306/xu_falask&#x27;</span></span><br><span class="line">SQLALCHEMY_TRACK_MODIFICATIONS = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">导包</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line">db = SQLAlchemy(app)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生sql插入</span></span><br><span class="line">db.session.execute(</span><br><span class="line">        <span class="string">&#x27;insert into goods(name,price,user_name,stact,num,creact_time)  value(&quot;%s&quot;,%d,&quot;%s&quot;,%d,%d,&quot;%s&quot;)&#x27;</span> % (</span><br><span class="line">            name, int(price), user_name, <span class="number">1</span>, int(num), now_time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>)))</span><br><span class="line">    db.session.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生sql语句查询</span></span><br><span class="line">goods = db.session.execute(<span class="string">&#x27;select * from goods where stact=1 and user_name=&quot;%s&quot;&#x27;</span> % name).fetchall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生sql语句修改</span></span><br><span class="line">db.session.execute(<span class="string">&#x27;update goods set stact=0 where name=&quot;%s&quot;&#x27;</span> % name)</span><br><span class="line">    db.session.commit()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说直接上代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>redis最完整的解释</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2017/11/19/redis%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2017/11/19/redis%E6%9C%80%E5%AE%8C%E6%95%B4%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2017-11-19T10:58:17.000Z</published>
    <updated>2020-09-03T13:00:12.750Z</updated>
    
    <content type="html"><![CDATA[<p>简介</p><p>Redis （全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它是一个运行在内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p><p>我们平时在项目中设计数据访问的时候往往都是采用直接访问数据库，采用数据库连接池来实现，但是如果我们的项目访问量过大或者访问过于频繁，将会对我们的数据库带来很大的压力。为了解决这个问题从而redis数据库脱颖而出，redis数据库出现时是以非关系数据库的光环展示在广大程序猿的面前的，后来redis的迭代版本支持了缓存数据、登录session状态（分布式session共享）等。所以又被作为内存缓存的形式应用到大型企业级项目中。</p><p>Redis是什么？<br>主流的理解有以下三种</p><p>1.key value store.是一个以key-value形式存储的数据库，定位直指MySQL，用来作为唯一的存储系统。</p><p>2.memory cache.是一个把数据存储在内存中的高速缓存，用来在应用和数据库间提供缓冲，替代memcachd。</p><p>3.data structrue server.把它支持对复杂数据结构的高速操作作为卖点，提供某些特殊业务场景的计算和展现需求。比如排行榜应用，Top 10之类的。</p><p>Redis特点<br>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><p>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</p><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p><p>Redis支持数据的备份，即master-slave模式的数据备份。</p><p>Redis 优势<br>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。这主要归功于这些数据都存在于内存中，并且是单线程。</p><p>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p><p>原子性 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>丰富的特性 – Redis还支持 publish/subscribe（发布/订阅）、通知,、key 过期、Lua 脚本、事务、Pipeline（管道，即当指令到达一定数量后，客户端才会执行）等等特性。</p><p>兼容性强 – 支持多种编程语言。支持Java、PHP、Golang、Python、Ruby、Lua、Nodejs等。</p><p>高可用和分布式 – Redis-Sentinel（v2.8）支持高可用，Redis-Cluster（v3.0）支持分布式</p><p>Redis使用场景<br>1、缓存——热数据</p><p>这是 Redis 使用最多的场景。Redis 能够替代 Memcached，让你的缓存从只能存储数据变得能够更新数据，因此你不再需要每次都重新生成数据。</p><p>2、计数器</p><p>诸如统计点击数、转发数、评论数等应用。由于单线程，可以避免并发问题，保证不会出错，而且100%毫秒级性能！爽。 命令：INCRBY 当然爽完了，别忘记持久化，毕竟是redis只是存了内存！</p><p>3、消息队列</p><p>相当于消息系统，运行稳定并且快速，支持模式匹配，能够实时订阅与取消频道，和ActiveMQ，RocketMQ等工具类似，但是个人觉得简单用一下还行，如果对于数据一致性要求高的话还是用RocketMQ等专业系统。 由于redis把数据添加到队列是返回添加元素在队列的第几位，所以可以做判断用户是第几个访问这种业务 队列不仅可以把并发请求变成串行，并且还可以做队列或者栈使用</p><p>4、位操作（大数据处理）</p><p>用于数据量上亿的场景下，例如几亿用户系统的签到，去重登录次数统计，某用户是否在线状态等等。 腾讯10亿用户，要几毫秒内查询到某个用户是否在线，你能怎么做？千万别说给每个用户建立一个key，然后挨个记（你可以算一下需要的内存会很恐怖，而且这种类似的需求很多，腾讯光这个得多花多少钱。。）这里要用到位操作——使用setbit、getbit、bitcount命令。</p><p>原理是： redis内构建一个足够长的数组，每个数组元素只能是0和1两个值，然后这个数组的下标index用来表示我们上面例子里面的用户id（必须是数字哈），那么很显然，这个几亿长的大数组就能通过下标和元素值（0和1）来构建一个记忆系统，上面我说的几个场景也就能够实现。用到的命令是：setbit、getbit、bitcount。</p><p>5、分布式锁与单线程机制</p><p>验证前端的重复请求（可以自由扩展类似情况），可以通过redis进行过滤：每次请求将request Ip、参数、接口等hash作为key存储redis（幂等性请求），设置多长时间有效期，然后下次请求过来的时候先在redis中检索有没有这个key，进而验证是不是一定时间内过来的重复提交 秒杀系统，基于redis是单线程特征，防止出现数据库“爆破” 全局增量ID生成，类似“秒杀”</p><p>6、最新列表</p><p>例如新闻列表页面最新的新闻列表，如果总数量很大的情况下，尽量不要使用select a from A limit 10这种low货，尝试redis的 LPUSH命令构建List，一个个顺序都塞进去就可以啦。不过万一内存清掉了咋办？也简单，查询不到存储key的话，用mysql查询并且初始化一个List到redis中就好了。</p><p>7、排行榜</p><p>谁得分高谁排名往上。命令：ZADD（有续集，sorted set）</p><p>（附）Redis命令目录<br>Key（键）<br>DEL<br>DUMP<br>EXISTS<br>EXPIRE<br>EXPIREAT<br>KEYS<br>MIGRATE<br>MOVE<br>OBJECT<br>PERSIST<br>PEXPIRE<br>PEXPIREAT<br>PTTL<br>RANDOMKEY<br>RENAME<br>RENAMENX<br>RESTORE<br>SORT<br>TTL<br>TYPE<br>SCAN</p><p>String（字符串）<br>APPEND<br>BITCOUNT<br>BITOP<br>BITFIELD<br>DECR<br>DECRBY<br>GET<br>GETBIT<br>GETRANGE<br>GETSET<br>INCR<br>INCRBY<br>INCRBYFLOAT<br>MGET<br>MSET<br>MSETNX<br>PSETEX<br>SET<br>SETBIT<br>SETEX<br>SETNX<br>SETRANGE<br>STRLEN</p><p>Hash（哈希表）<br>HDEL<br>HEXISTS<br>HGET<br>HGETALL<br>HINCRBY<br>HINCRBYFLOAT<br>HKEYS<br>HLEN<br>HMGET<br>HMSET<br>HSET<br>HSETNX<br>HVALS<br>HSCAN<br>HSTRLEN</p><p>List（列表）<br>BLPOP<br>BRPOP<br>BRPOPLPUSH<br>LINDEX<br>LINSERT<br>LLEN<br>LPOP<br>LPUSH<br>LPUSHX<br>LRANGE<br>LREM<br>LSET<br>LTRIM<br>RPOP<br>RPOPLPUSH<br>RPUSH<br>RPUSHX</p><p>Set（集合）<br>SADD<br>SCARD<br>SDIFF<br>SDIFFSTORE<br>SINTER<br>SINTERSTORE<br>SISMEMBER<br>SMEMBERS<br>SMOVE<br>SPOP<br>SRANDMEMBER<br>SREM<br>SUNION<br>SUNIONSTORE<br>SSCAN</p><p>SortedSet（有序集合）<br>ZADD<br>ZCARD<br>ZCOUNT<br>ZINCRBY<br>ZRANGE<br>ZRANGEBYSCORE<br>ZRANK<br>ZREM<br>ZREMRANGEBYRANK<br>ZREMRANGEBYSCORE<br>ZREVRANGE<br>ZREVRANGEBYSCORE<br>ZREVRANK<br>ZSCORE<br>ZUNIONSTORE<br>ZINTERSTORE<br>ZSCAN<br>ZRANGEBYLEX<br>ZLEXCOUNT<br>ZREMRANGEBYLEX</p><p>HyperLogLog<br>PFADD<br>PFCOUNT<br>PFMERGE</p><p>GEO（地理位置）<br>GEOADD<br>GEOPOS<br>GEODIST<br>GEORADIUS<br>GEORADIUSBYMEMBER<br>GEOHASH</p><p>Pub/Sub（发布/订阅）<br>PSUBSCRIBE<br>PUBLISH<br>PUBSUB<br>PUNSUBSCRIBE<br>SUBSCRIBE<br>UNSUBSCRIBE</p><p>Transaction（事务）<br>DISCARD<br>EXEC<br>MULTI<br>UNWATCH<br>WATCH</p><p>Script（脚本）<br>EVAL<br>EVALSHA<br>SCRIPT EXISTS<br>SCRIPT FLUSH<br>SCRIPT KILL<br>SCRIPT LOAD</p><p>Connection（连接）<br>AUTH<br>ECHO<br>PING<br>QUIT<br>SELECT</p><p>Server（服务器）<br>BGREWRITEAOF<br>BGSAVE<br>CLIENT GETNAME<br>CLIENT KILL<br>CLIENT LIST<br>CLIENT SETNAME<br>CONFIG GET<br>CONFIG RESETSTAT<br>CONFIG REWRITE<br>CONFIG SET<br>DBSIZE<br>DEBUG OBJECT<br>DEBUG SEGFAULT<br>FLUSHALL<br>FLUSHDB<br>INFO<br>LASTSAVE<br>MONITOR<br>PSYNC<br>SAVE<br>SHUTDOWN<br>SLAVEOF<br>SLOWLOG<br>SYNC<br>TIME</p><h1 id="redis五大数据类型"><a href="#redis五大数据类型" class="headerlink" title="redis五大数据类型"></a>redis五大数据类型</h1><h2 id="Redis支持五种数据类型："><a href="#Redis支持五种数据类型：" class="headerlink" title="Redis支持五种数据类型："></a>Redis支持五种数据类型：</h2><p>string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h2 id="redis五大数据类型实现原理"><a href="#redis五大数据类型实现原理" class="headerlink" title="redis五大数据类型实现原理"></a>redis五大数据类型实现原理</h2><p>目录<br>1、对象的类型与编码</p><p>2、字符串对象</p><p>3、列表对象</p><p>4、哈希对象</p><p>5、集合对象</p><p>6、有序集合对象</p><p>7、五大数据类型的应用场景</p><p>8、内存回收和内存共享</p><p>9、对象的空转时长</p><p>　　在Redis中，并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这些对象系统也就是前面说的五大数据类型，每一种数据类型都至少用到了一种数据结构。通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型判断一个对象是否可以执行给定的命令，而且可以针对不同的场景，为对象设置多种不同的数据结构，从而优化对象在不同场景下的使用效率。</p><h4 id="1、对象的类型与编码"><a href="#1、对象的类型与编码" class="headerlink" title="1、对象的类型与编码"></a>1、对象的类型与编码</h4><p>　　Redis使用前面说的五大数据类型来表示键和值，每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象，而Redis中的每个对象都是由 redisObject 结构来表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;类型</span><br><span class="line"></span><br><span class="line">     unsigned type:4;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;编码</span><br><span class="line"></span><br><span class="line">     unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;指向底层数据结构的指针</span><br><span class="line"></span><br><span class="line">     void *ptr;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;引用计数</span><br><span class="line"></span><br><span class="line">     int refcount;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;记录最后一次被程序访问的时间</span><br><span class="line"></span><br><span class="line">     unsigned lru:22;</span><br><span class="line"></span><br><span class="line">&#125;robj</span><br></pre></td></tr></table></figure><p>①、type属性</p><p>对象的type属性记录了对象的类型，这个类型就是前面讲的五大数据类型：<br><img src="https://img-blog.csdnimg.cn/20200730114725844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以通过如下命令来判断对象类型：<br>1     | type<br>——– | —–<br><img src="https://img-blog.csdnimg.cn/20200730114933965.png" alt="在这里插入图片描述"><br>注意：在Redis中，键总是一个字符串对象，而值可以是字符串、列表、集合等对象，所以我们通常说的键为字符串键，表示的是这个键对应的值为字符串对象，我们说一个键为集合键时，表示的是这个键对应的值为集合对象。<br>②、encoding 属性和 *prt 指针<br>　对象的 prt 指针指向对象底层的数据结构，而数据结构由 encoding 属性来决定。<br><img src="https://img-blog.csdnimg.cn/20200730115001858.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　而每种类型的对象都至少使用了两种不同的编码：<br><img src="https://img-blog.csdnimg.cn/20200730115021438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　可以通过如下命令查看值对象的编码：<br>　1     | OBJECT ENCODING    key<br>——– | —–<br>　比如 string 类型：（可以是 embstr编码的简单字符串或者是 int 整数值实现）<br>　<img src="https://img-blog.csdnimg.cn/20200730115108340.png" alt="在这里插入图片描述"><br>2、字符串对象<br>　　字符串是Redis最基本的数据类型，不仅所有key都是字符串类型，其它几种数据类型构成的元素也是字符串。注意字符串的长度不能超过512M。</p><p>　　①、编码</p><p>　　字符串对象的编码可以是int，raw或者embstr。</p><p>　　1、int 编码：保存的是可以用 long 类型表示的整数值。</p><p>　　2、raw 编码：保存长度大于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。</p><p>　　3、embstr 编码：保存长度小于44字节的字符串（redis3.2版本之前是39字节，之后是44字节）。<br><img src="https://img-blog.csdnimg.cn/20200730115125291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　由上可以看出，int 编码是用来保存整数值，raw编码是用来保存长字符串，而embstr是用来保存短字符串。其实 embstr 编码是专门用来保存短字符串的一种优化编码，raw 和 embstr 的区别：<br><img src="https://img-blog.csdnimg.cn/20200730115137332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730115151399.png" alt="在这里插入图片描述"><br>　embstr与raw都使用redisObject和sds保存数据，区别在于，embstr的使用只分配一次内存空间（因此redisObject和sds是连续的），而raw需要分配两次内存空间（分别为redisObject和sds分配空间）。因此与raw相比，embstr的好处在于创建时少分配一次空间，删除时少释放一次空间，以及对象的所有数据连在一起，寻找方便。而embstr的坏处也很明显，如果字符串的长度增加需要重新分配内存时，整个redisObject和sds都需要重新分配空间，因此redis中的embstr实现为只读。</p><p>　　ps：Redis中对于浮点数类型也是作为字符串保存的，在需要的时候再将其转换成浮点数类型。</p><p>　　②、编码的转换</p><p>　　当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw。</p><p>　　对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。<br>　　3、列表对象<br>　　list 列表，它是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层实际上是个链表结构。</p><p>　　①、编码</p><p>　　列表对象的编码可以是 ziplist(压缩列表) 和 linkedlist(双端链表)。 关于链表和压缩列表的特性可以看我前面的这篇博客。</p><p>　　比如我们执行以下命令，创建一个 key = ‘numbers’，value = ‘1 three 5’ 的三个值的列表。<br>　1     | rpush numbers 1 “three” 5<br>———|———–<br>　ziplist 编码表示如下：<br><img src="https://img-blog.csdnimg.cn/20200730115351403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730115402538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　②、编码转换</p><p>　　当同时满足下面两个条件时，使用ziplist（压缩列表）编码：</p><p>　　1、列表保存元素个数小于512个</p><p>　　2、每个元素长度小于64字节</p><p>　　不能满足这两个条件的时候使用 linkedlist 编码。</p><p>　　上面两个条件可以在redis.conf 配置文件中的 list-max-ziplist-value选项和 list-max-ziplist-entries 选项进行配置。<br>　　4、哈希对象<br>　　哈希对象的键是一个字符串类型，值是一个键值对集合。</p><p>　　①、编码</p><p>　　哈希对象的编码可以是 ziplist 或者 hashtable。</p><p>　　当使用ziplist，也就是压缩列表作为底层实现时，新增的键值对是保存到压缩列表的表尾。比如执行以下命令：<br>　　　1     |hset profile name “Tom”<br>———|———–<br>2     |   hset profile age 25<br>3|hset profile career “Programmer”<br>　　如果使用ziplist，profile 存储如下：<br>　　<img src="https://img-blog.csdnimg.cn/20200730115531362.png" alt="在这里插入图片描述"><br>当使用 hashtable 编码时，上面命令存储如下：<br><img src="https://img-blog.csdnimg.cn/2020073011554657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>hashtable 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。</p><p>　　在前面介绍压缩列表时，我们介绍过压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。</p><p>　　②、编码转换</p><p>　　和上面列表对象使用 ziplist 编码一样，当同时满足下面两个条件时，使用ziplist（压缩列表）编码：</p><p>　　1、列表保存元素个数小于512个</p><p>　　2、每个元素长度小于64字节</p><p>　　不能满足这两个条件的时候使用 hashtable 编码。第一个条件可以通过配置文件中的 set-max-intset-entries 进行修改。</p><p>5、集合对象<br> 　　集合对象 set 是 string 类型（整数也会转换成string类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。</p><p>　　①、编码</p><p>　　集合对象的编码可以是 intset 或者 hashtable。</p><p>　　intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中。</p><p>　　hashtable 编码的集合对象使用 字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。这里可以类比Java集合中HashSet 集合的实现，HashSet 集合是由 HashMap 来实现的，集合中的元素就是 HashMap 的key，而 HashMap 的值都设为 null。<br>　　　1     |     SADD numbers 1 3 5<br>———|———–<br><img src="https://img-blog.csdnimg.cn/20200730115628591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>1|SADD Dfruits “apple” “banana” “cherry”<br>—–|—<br><img src="https://img-blog.csdnimg.cn/20200730115654208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　②、编码转换</p><p>　　当集合同时满足以下两个条件时，使用 intset 编码：</p><p>　　1、集合对象中所有元素都是整数</p><p>　　2、集合对象所有元素数量不超过512</p><p>　　不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的 set-max-intset-entries 进行配置。</p><p>6、有序集合对象<br>　　和上面的集合对象相比，有序集合对象是有序的。与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。</p><p>　　①、编码</p><p>　　有序集合的编码可以是 ziplist 或者 skiplist。</p><p>　　ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。<br>　　1|ZADD price 8.5 apple 5.0 banana 6.0 cherry<br>—|—-<br><img src="https://img-blog.csdnimg.cn/20200730115731851.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730115736295.png" alt="在这里插入图片描述"><br>skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset&#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;跳跃表</span><br><span class="line"></span><br><span class="line">     zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;字典</span><br><span class="line"></span><br><span class="line">     dict *dice;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><p>字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。</p><p>　　这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。</p><p>　　说明：其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。</p><p>　　②、编码转换</p><p>　　当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：</p><p>　　1、保存的元素数量小于128；</p><p>　　2、保存的所有元素长度都小于64字节。</p><p>　　不能满足上面两个条件的使用 skiplist 编码。以上两个条件也可以通过Redis配置文件zset-max-ziplist-entries 选项和 zset-max-ziplist-value 进行修改。</p><p>7、五大数据类型的应用场景<br>　　对于string 数据类型，因为string 类型是二进制安全的，可以用来存放图片，视频等内容，另外由于Redis的高性能读写功能，而string类型的value也可以是数字，可以用作计数器（INCR,DECR），比如分布式环境中统计系统的在线人数，秒杀等。</p><p>　　对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。</p><p>　　对于 list 数据类型，可以实现简单的消息队列，另外可以利用lrange命令，做基于redis的分页功能</p><p>　　对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>　　对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等。</p><p>8、内存回收和内存共享</p><p>①、内存回收</p><p>　　前面讲 Redis 的每个对象都是由 redisObject 结构表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject&#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;类型</span><br><span class="line"></span><br><span class="line">     unsigned type:4;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;编码</span><br><span class="line"></span><br><span class="line">     unsigned encoding:4;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;指向底层数据结构的指针</span><br><span class="line"></span><br><span class="line">     void *ptr;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;引用计数</span><br><span class="line"></span><br><span class="line">     int refcount;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;记录最后一次被程序访问的时间</span><br><span class="line"></span><br><span class="line">     unsigned lru:22;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;robj</span><br></pre></td></tr></table></figure><p>　其中关键的 type属性，encoding 属性和 ptr 指针都介绍过了，那么 refcount 属性是干什么的呢？</p><p>　　因为 C 语言不具备自动回收内存功能，那么该如何回收内存呢？于是 Redis自己构建了一个内存回收机制，通过在 redisObject 结构中的 refcount 属性实现。这个属性会随着对象的使用状态而不断变化：</p><p>　　1、创建一个新对象，属性 refcount 初始化为1</p><p>　　2、对象被一个新程序使用，属性 refcount 加 1</p><p>　　3、对象不再被一个程序使用，属性 refcount 减 1</p><p>　　4、当对象的引用计数值变为 0 时，对象所占用的内存就会被释放。</p><p>　　在 Redis 中通过如下 API 来实现：<br>　　<img src="https://img-blog.csdnimg.cn/20200730115900823.png" alt="在这里插入图片描述"><br>　学过Java的应该知道，引用计数的内存回收机制其实是不被Java采用的，因为不能克服循环引用的例子（比如 A 具有 B 的引用，B 具有 C 的引用，C 具有 A 的引用，除此之外，这三个对象没有任何用处了），这时候 A B C 三个对象会一直驻留在内存中，造成内存泄露。那么 Redis 既然采用引用计数的垃圾回收机制，如何解决这个问题呢？</p><p>　　在前面介绍 redis.conf 配置文件时，在  MEMORY MANAGEMENT 下有个 maxmemory-policy 配置：</p><p>　　maxmemory-policy ：当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：</p><p>　　　　1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) </p><p>　　　　2）allkeys-lru   利用LRU算法移除任何key </p><p>　　　　3）volatile-random 移除设置过过期时间的随机key </p><p>　　　　4）allkeys-random  移除随机key</p><p>　　　　5）volatile-ttl   移除即将过期的key(minor TTL) </p><p>　　　　6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项</p><p>　　通过这种配置，也可以对内存进行回收。</p><p>②、内存共享 </p><p>　　refcount 属性除了能实现内存回收以外，还能用于内存共享。</p><p>　　比如通过如下命令 set k1 100,创建一个键为 k1，值为100的字符串对象，接着通过如下命令 set k2 100 ，创建一个键为 k2，值为100 的字符串对象，那么 Redis 是如何做的呢？</p><p>　　1、将数据库键的值指针指向一个现有值的对象</p><p>　　2、将被共享的值对象引用refcount 加 1<br>　　<img src="https://img-blog.csdnimg.cn/20200730115914627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　注意：Redis的共享对象目前只支持整数值的字符串对象。之所以如此，实际上是对内存和CPU（时间）的平衡：共享对象虽然会降低内存消耗，但是判断两个对象是否相等却需要消耗额外的时间。对于整数值，判断操作复杂度为O(1)；对于普通字符串，判断复杂度为O(n)；而对于哈希、列表、集合和有序集合，判断的复杂度为O(n^2)。</p><p>　　虽然共享对象只能是整数值的字符串对象，但是5种类型都可能使用共享对象（如哈希、列表等的元素可以使用）。</p><p>9、对象的空转时长<br>　　在 redisObject 结构中，前面介绍了 type、encoding、ptr 和 refcount 属性，最后一个 lru 属性，该属性记录了对象最后一次被命令程序访问的时间。</p><p>　　使用 OBJECT IDLETIME 命令可以打印给定键的空转时长，通过将当前时间减去值对象的 lru 时间计算得到。<br>　　<img src="https://img-blog.csdnimg.cn/20200730115927457.png" alt="在这里插入图片描述"><br>lru 属性除了计算空转时长以外，还可以配合前面内存回收配置使用。如果Redis打开了maxmemory选项，且内存回收算法选择的是volatile-lru或allkeys—lru，那么当Redis内存占用超过maxmemory指定的值时，Redis会优先选择空转时间最长的对象进行释放。</p><h2 id="redis五大数据类型常用命令"><a href="#redis五大数据类型常用命令" class="headerlink" title="redis五大数据类型常用命令"></a>redis五大数据类型常用命令</h2><p><a href="https://www.runoob.com/redis/redis-data-types.html">https://www.runoob.com/redis/redis-data-types.html</a></p><h2 id="redis持久化原理"><a href="#redis持久化原理" class="headerlink" title="redis持久化原理"></a>redis持久化原理</h2><p>redis支持非常丰富的内存数据结构类型，redis一共支持4种持久化方式：</p><p>1、定时快照方式（snapshot）</p><p>2、基于语句追加文件的方式（aof）</p><p>3、虚拟内存</p><p>4、Diskstore方式</p><p>redis支持小量数据落地功能，后两种方式兵不成熟，下面分别介绍下这几种持久化方式：</p><p>定时快照方式（snapshot）：</p><p>该持久化方式实际是在redis内部一个定时器事件，每隔固定事件去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则，通过操作fork调用来创建出一个子进程，这个子进程默认会与父进程贡献相同的地址空间，这就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页（page）为单位来进行copy-on-write保证父子进程之间不会互相影响。该持久化的主要缺点是定时快照只是代表一段时间内的内存映射，所以系统重启会丢失上次快照与重启之间所有的数据。</p><p>基于语句追加方式（aof）：</p><p>aof方式实际类型似mysql的基于语句binlog方式，即每条会使redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是redis的持久化数据。</p><p>aof的方式主要缺点是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log，所以使用aof的方式，redis的读写性能也会有所下降。</p><h2 id="什么是redis哨兵模式"><a href="#什么是redis哨兵模式" class="headerlink" title="什么是redis哨兵模式"></a>什么是redis哨兵模式</h2><p>哨兵模式是一种特殊模式，首先redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的redis实例。</p><p>Sentinel（哨兵）是Redis的高可用性解决方案：由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态，自动将下线主服务器属下的某个从服务器升级为新的主服务器。</p><p>主要功能：</p><p>1、不时的监控redis是否按照预期良好的运行；</p><p>2、如果发生某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端)。</p><p>3、能够进行自动切换，当一个mater节点不可用时能够选举出master的多个slave（如果有超过一个slave的话）中的一个来作为新的master，其他的slave节点会将它所追随的master地址改为被提升master的slave的新地址。</p><p>4、哨兵为客户端提供服务发现，客户端练肌肉哨兵，哨兵提供当前master的地址然后提供服务，如果出现切换，也就是master挂了，哨兵会提供客户端一个新地址。</p><h1 id="redis击穿、穿透、雪崩以及解决方案"><a href="#redis击穿、穿透、雪崩以及解决方案" class="headerlink" title="redis击穿、穿透、雪崩以及解决方案"></a>redis击穿、穿透、雪崩以及解决方案</h1><p>1 击穿: 指的是单个key在缓存中查不到，去数据库查询，这样如果数据量不大或者并发不大的话是没有什么问题的。</p><p>   如果数据库数据量大并且是高并发的情况下那么就可能会造成数据库压力过大而崩溃</p><p>注意: 这里指的是单个key发生高并发!!!</p><p>解决方案:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1) 通过synchronized+双重检查机制：某个key只让一个线程查询，阻塞其它线程</span><br><span class="line">    在同步块中，继续判断检查，保证不存在，才去查DB。</span><br><span class="line"> 例如:    </span><br><span class="line"> private static volaite Object lockHelp&#x3D;new Object();</span><br><span class="line">  public String getValue(String key)&#123;</span><br><span class="line">    String value&#x3D;redis.get(key,String.class);</span><br><span class="line">    if(value&#x3D;&#x3D;&quot;null&quot;||value&#x3D;&#x3D;null||StringUtils.isBlank(value)&#123;</span><br><span class="line">        synchronized(lockHelp)&#123;</span><br><span class="line">               value&#x3D;redis.get(key,String.class);</span><br><span class="line">                if(value&#x3D;&#x3D;&quot;null&quot;||value&#x3D;&#x3D;null||StringUtils.isBlank(value)&#123;</span><br><span class="line">                    value&#x3D;db.query(key);</span><br><span class="line">                     redis.set(key,value,1000);</span><br><span class="line">                 &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          &#125;    </span><br><span class="line">       return value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缺点: 会阻塞其它线程</p><ol start="2"><li><p>设置value永不过期</p><p> 这种方式可以说是最可靠的，最安全的但是占空间，内存消耗大，并且不能保持数据最新 这个需要根据具体的业务逻辑来做 </p><p>个人觉得如果要保持数据最新不放这么试试，仅供参考：</p><p>起个定时任务或者利用TimerTask 做定时，每个一段时间多这些值进行数据库查询更新一次缓存，当然前提时不会给数据库造成压力过大(这个很重要)</p></li><li><p>使用互斥锁(mutex key)</p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p></li></ol><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。在redis2.6.1之前版本未实现setnx的过期时间，所以这里给出两种版本代码参考：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public String get(key) &#123;</span><br><span class="line">      String value &#x3D; redis.get(key);</span><br><span class="line">      if (value &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;代表缓存值过期</span><br><span class="line">          &#x2F;&#x2F;设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span><br><span class="line">          if (redis.setnx(key_mutex, 1, 3 * 60) &#x3D;&#x3D; 1) &#123;  &#x2F;&#x2F;代表设置成功</span><br><span class="line">               value &#x3D; db.get(key);</span><br><span class="line">                      redis.set(key, value, expire_secs);</span><br><span class="line">                      redis.del(key_mutex);</span><br><span class="line"></span><br><span class="line">                     return value;</span><br><span class="line">              &#125; else &#123;  &#x2F;&#x2F;这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span><br><span class="line">                      sleep(10);</span><br><span class="line">                      get(key);  &#x2F;&#x2F;重试</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return value;      </span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缺点:</p><ol><li><p>代码复杂度增大</p></li><li><p>存在死锁的风险</p></li><li><p>存在线程池阻塞的风险</p></li></ol><p>2 雪崩</p><p>雪崩指的是多个key查询并且出现高并发，缓存中失效或者查不到，然后都去db查询，从而导致db压力突然飙升，从而崩溃。</p><p>出现原因:<br> 1 key同时失效<br> 2 redis本身崩溃了</p><p>方案:</p><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。(跟击穿的第一个方案类似，但是这样是避免不了其它key去查数据库，只能减少查询的次数)<br>可以通过缓存reload机制，预先去更新缓存，再即将发生大并发访问前手动触发加载缓存<br>不同的key，设置不同的过期时间，具体值可以根据业务决定，让缓存失效的时间点尽量均匀<br>做二级缓存，或者双缓存策略。A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期。(这种方式复杂点)<br>3 击透</p><p>   一般是出现这种情况是因为恶意频繁查询才会对系统造成很大的问题: key缓存并且数据库不存在，所以每次查询都会查询数据库从而导致数据库崩溃。</p><p>解决方案:</p><pre><code>      1) 使用布隆过滤器: 热点数据等场景(具体看使用场景)</code></pre><p>布隆过滤器是什么？</p><p>布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><p>当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。</p><p>缺点: 1 会存在一定的误判率</p><pre><code>      2  对新增加的数据无法进行布隆过滤      3 数据的key不会频繁的更改</code></pre><p>   google 的 gauva 中有布隆过滤的实现</p><pre><code> BloomFilter的关键在于hash算法的设定和bit数组的大小确定，通过权衡得到一个错误概率可以接受的结果。 我们设置的容错率越小那么过滤函数也就多，分配的空间也就越大(存放bits)，那么误判率也就越小。</code></pre><p>2 将击透的key缓存起来，但是时间不能太长，下次进来是直接返回不存在，但是这种情况无法过滤掉动态的key，就是说每次请求进来都是不同额key，这样还是会造成这个问题</p><h1 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h1><p>Redis事务的概念：</p><p>　　Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>　　总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　</p><p>Redis事务没有隔离级别的概念：</p><p>　　批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。<br>Redis不保证原子性：</p><p>　　Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p><p>Redis事务的三个阶段：</p><p>开始事务<br>命令入队<br>执行事务<br>Redis事务相关命令：</p><p>　　watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</p><p>　　multi : 标记一个事务块的开始（ queued ）</p><p>　　exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</p><p>　　discard : 取消事务，放弃事务块中的所有命令</p><p>　　unwatch : 取消watch对所有key的监控</p><p>Redis事务使用案例：</p><p>（1）正常执行<br><img src="https://img-blog.csdnimg.cn/20200730134958394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（2）放弃事务<br><img src="https://img-blog.csdnimg.cn/20200730135013872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（3）若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行<br><img src="https://img-blog.csdnimg.cn/20200730135043261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（4）若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。<br><img src="https://img-blog.csdnimg.cn/20200730135051943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>（5）使用watch</p><p>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功<br><img src="https://img-blog.csdnimg.cn/20200730135112415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。<br><img src="https://img-blog.csdnimg.cn/20200730135127649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。</p><p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>　　watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。</p><h2 id="redis乐观锁"><a href="#redis乐观锁" class="headerlink" title="redis乐观锁"></a>redis乐观锁</h2><p>乐观锁（又名乐观并发控制，Optimistic Concurrency Control，缩写“OCC”），是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。</p><p>与乐观所相对的，就是悲观锁（又名悲观并发控制，Pessimistic Concurrency Control，缩写“PCC”），它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p><p>通俗的说，就是悲观锁就是“先取锁在访问”，因为悲观锁会“悲观”地认为访问会产生冲突，因此这种保守的策略虽然在数据处理的安全行上提供了保障，但是在效率方面会让数据库产生极大的开销，而且还有可能出现死锁的情况。</p><p>在Redis中WATCH命令的实现是基于乐观锁，即，假设访问不会产生冲突，但是在提交数据之前会先检查该事务该事物读取数据后，其他事务是否修改数据，如果其他事务修改了数据，像MySQL提供了回滚操作，而Redis不支持回滚，因为antirez认为这与Redis简单高效的设计主旨不相符，并且Redis事务执行时错误在开发环境时是可以避免的。</p><p>乐观锁控制的事务一般包括三个阶段：</p><p>读取：当执行完MULTI命令后，客户端进入事务模式，客户端接下来输入的命令会读入到事务队列中，入队过程中出错会设置CLIENT_DIRTY_EXEC标识。<br>校验：如果数据库有键被修改，那么会检测被修改的键是否是被WATCH命令监视的命令，如果是则会设置对应的标识（CLIENT_DIRTY_CAS），并且在命令执行前会检测这两个标识，如果检测到该标识，则会取消事务的执行。<br>写入：如果没有设置以上两种标识，那么会执行事务的命令，而Redis是单进程模型，因此可以避免执行事务命令时其他请求可能修改数据库键的可能。<br>Redis的乐观锁不是通常实现乐观锁的一般方法：检测版本号，而是在执行完一个写命令后，会进行检查，检查是否是被WATCH监视的键。 </p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p> 悲观锁（Pessimistic Lock），顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，当其他线程想要访问数据时，都需要阻塞挂起。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁、表锁，读锁，写锁等，都是在操作之前先上锁。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁，是一种思想，它的实现方式有很多。比如，我们将沙滩当做分布式锁的组件，那么它看起来应该是这样的：</p><p>.加锁<br>在沙滩上踩一脚，留下自己的脚印，就对应了加锁操作。其他进程或者线程，看到沙滩上已经有脚印，证明锁已被别人持有，则等待。</p><p>解锁<br>把脚印从沙滩上抹去，就是解锁的过程。</p><p>锁超时<br>为了避免死锁，我们可以设置一阵风，在单位时间后刮起，将脚印自动抹去。</p><p>分布式锁的实现有很多，比如基于数据库、memcached、Redis、系统文件、zookeeper等。它们的核心的理念跟上面的过程大致相同。</p><h2 id="Hash冲突"><a href="#Hash冲突" class="headerlink" title="Hash冲突"></a>Hash冲突</h2><p>1、 什么是hash表</p><p>根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为哈希表，这一映像过程称为哈希造表或者散列，所得的存储位置称哈希地址或散列地址。</p><p>2、 hash冲突</p><p>对应不同的关键字可能获得相同的hash地址，即 key1≠key2，但是f(key1)=f(key2)。这种现象就是冲突，而且这种冲突只能尽可能的减少，不能完全避免。因为哈希函数是从关键字集合和地址集合的映像，通常关键字集合比较大，而地址集合的元素仅为哈希表中的地址值。</p><p>3、 处理冲突的方法。</p><p>通常用的冲突处理方法有以下几种：</p><p>(1)、开放定址法<br><img src="https://img-blog.csdnimg.cn/20200805081435649.png" alt="[公式]"><br>其中H(key)为hash函数，m为哈希表的长度， [公式] 为增量序列，其取值有三种防止：a、线性探测再散列： <img src="https://img-blog.csdnimg.cn/20200805081457758.png" alt="[公式]"><br>b、二次探测再散列：<br><img src="https://img-blog.csdnimg.cn/20200805081525280.png" alt="[公式]"><br>c、随机探测再散列，<br><img src="https://img-blog.csdnimg.cn/20200805081542310.png" alt="[公式]"><br>eg：H(key) = key MOD 7，哈希表中已经存在关键字：11，12，15，在插入</p><p>关键字18的时候，通过哈希函数的到的地址为4，产生冲突，使用线性探测得到的下一个地址为5，依然冲突，继续探测得到地址6，为空，冲突处理结束，使用二次探测解决冲突第一个地址为5，冲突，再次探测，地址为3，为空，冲突处理结束。</p><p>线性探测：<br><img src="https://img-blog.csdnimg.cn/20200805081601214.png" alt="在这里插入图片描述"><br>二次探测：<br><img src="https://img-blog.csdnimg.cn/2020080508161287.png" alt="在这里插入图片描述"><br>随机探测：<br><img src="https://img-blog.csdnimg.cn/20200805081634721.png" alt="在这里插入图片描述"><br>从上述可以看出使用线性探测的时候，当i，i+1,位置上都已填有记录的时候，下一个哈希地址为，i，i+1i+2的记录都将填入i+2的地址，者会造成第一个哈希地址不同的记录争夺同一个后继哈希地址的现象称为“二次聚集”，即在处理相同哈希值冲突的时候造成了不同哈希值的冲突，但是在另一个方面可以看出，只要未满使用线性探测总能找到空位置。</p><p>（2）、在哈希法<br><img src="https://img-blog.csdnimg.cn/20200805081725807.png" alt="在这里插入图片描述"><br>[公式] 都是不同的哈希函数，对产生地址冲突的关键字再次进行哈希计算，获取另一个哈希地址，知道不在产生冲突，这种方法不易产生“二次聚集”，但是增加的计算的时间。</p><p>（3）、链地址法</p><p>每个哈希地址对应的一个线性表，将地址相同的记录按序写入链表，这种处理方法如果收到哈希共计，出现大量的哈希冲突，会导致查询的时间复杂度增长，甚至退化为O(n)，为了提高查询效率我们可以使用跳表或者红黑树等结构替换线性表。</p><p>eg: H(key) = key MOD 7，已存在的记录为，0，4，7，9，11，12<br><img src="https://img-blog.csdnimg.cn/20200805081741644.png" alt="本图片来源于网络,如有侵权立删"><br>（4）、建立公共溢出区<br>顾名思义，在创建哈希表时，同时创建另一个表，将所有发生哈希冲突的记录都存储到溢出表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;Redis （全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它是一个运行在内存中的数据结构存储系统，它</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>celery使用+定义时间任务</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2017/10/30/celery%E4%BD%BF%E7%94%A8+%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2017/10/30/celery%E4%BD%BF%E7%94%A8+%E5%AE%9A%E4%B9%89%E6%97%B6%E9%97%B4%E4%BB%BB%E5%8A%A1/</id>
    <published>2017-10-30T02:16:10.000Z</published>
    <updated>2020-09-03T12:51:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先说明我用的django框架,那么为什么要使用celery框架,django3.0以下版本都是同步处理请求,假设我现在有一万个任务,我的django框架是承受不了的,所以就用到了clery异步.</p><p><img src="https://img-blog.csdnimg.cn/20200805193534384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70"></p><p><img src="https://img-blog.csdnimg.cn/20200805193840788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70"></p><h3 id="首先在settings配置"><a href="#首先在settings配置" class="headerlink" title="首先在settings配置"></a>首先在settings配置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 异步任务代理</span></span><br><span class="line">CELERY_BROKER_URL = <span class="string">&#x27;redis://127.0.0.1:6379/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务结果</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">&#x27;redis://127.0.0.1:6379/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存格式</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">&#x27;json&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="在项目下创建一个celery-py-在里面写"><a href="#在项目下创建一个celery-py-在里面写" class="headerlink" title="在项目下创建一个celery.py     在里面写"></a>在项目下创建一个celery.py     在里面写</h3><p><img src="https://img-blog.csdnimg.cn/20200805193920805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;liuyue_good.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册Celery的app</span></span><br><span class="line">app = Celery(<span class="string">&#x27;liuyue_good&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定配置文件</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>, namespace=<span class="string">&#x27;CELERY&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发现各个app下的tasks.py文件</span></span><br><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></table></figure><h3 id="在-init中写"><a href="#在-init中写" class="headerlink" title="在__init中写"></a>在__init中写</h3><p><img src="https://img-blog.csdnimg.cn/20200805195318446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">os.environ.setdefault(<span class="string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="string">&#x27;liuyue_good.settings&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册Celery的app</span></span><br><span class="line">app = Celery(<span class="string">&#x27;liuyue_good&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定配置文件</span></span><br><span class="line">app.config_from_object(<span class="string">&#x27;django.conf:settings&#x27;</span>, namespace=<span class="string">&#x27;CELERY&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动发现各个app下的tasks.py文件</span></span><br><span class="line">app.autodiscover_tasks()</span><br></pre></td></tr></table></figure><h3 id="在-init中写-1"><a href="#在-init中写-1" class="headerlink" title="在__init中写"></a>在__init中写</h3><p><img src="https://img-blog.csdnimg.cn/20200805195318446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTQ5OTA0MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导包</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">pymysql.install_as_MySQLdb()</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;celery_app&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="在views中定义函数调用celery任务"><a href="#在views中定义函数调用celery任务" class="headerlink" title="在views中定义函数调用celery任务"></a>在views中定义函数调用celery任务</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> factory_test <span class="keyword">import</span> SimpleFactory</span><br><span class="line"><span class="keyword">from</span> myapp <span class="keyword">import</span> tasks</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> JsonResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用celery任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">celery_test</span>(<span class="params">request</span>):</span></span><br><span class="line">    tasks.aync_test.delay()</span><br><span class="line">    SimpleFactory.ThirdLogin(<span class="string">&quot;gitee&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> JsonResponse(&#123;<span class="string">&#x27;task_id&#x27;</span>: <span class="string">&#x27;Hello python&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="最后启动celery"><a href="#最后启动celery" class="headerlink" title="最后启动celery"></a>最后启动celery</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># celery协程启动命令</span></span><br><span class="line">celery worker -A liuyue_good -l info -P eventlet</span><br></pre></td></tr></table></figure><h2 id="问题来了-怎么用celery设置一个定时任务呢"><a href="#问题来了-怎么用celery设置一个定时任务呢" class="headerlink" title="问题来了  怎么用celery设置一个定时任务呢????"></a>问题来了  怎么用celery设置一个定时任务呢????</h2><h3 id="别急这就来了"><a href="#别急这就来了" class="headerlink" title="别急这就来了"></a>别急这就来了</h3><p>在settings里配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CELERY_BEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="comment"># 定义定时任务</span></span><br><span class="line">    <span class="string">&#x27;celery_work&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;task&#x27;</span>: <span class="string">&#x27;myapp.tasks.aync_test&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;schedule&#x27;</span>: timedelta(seconds=<span class="number">30</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动定时任务也要有的"><a href="#启动定时任务也要有的" class="headerlink" title="启动定时任务也要有的"></a>启动定时任务也要有的</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还要启动一个定时任务的服务</span></span><br><span class="line">celery -A liuyue_good beat -l info</span><br></pre></td></tr></table></figure><h3 id="这样一个完整的celery就完成了-是不是感觉有点麻烦-别急嘛-还有简单一点的"><a href="#这样一个完整的celery就完成了-是不是感觉有点麻烦-别急嘛-还有简单一点的" class="headerlink" title="这样一个完整的celery就完成了   是不是感觉有点麻烦  别急嘛  还有简单一点的"></a>这样一个完整的celery就完成了   是不是感觉有点麻烦  别急嘛  还有简单一点的</h3><h4 id="在根目录下创建一个文件夹"><a href="#在根目录下创建一个文件夹" class="headerlink" title="在根目录下创建一个文件夹"></a>在根目录下创建一个文件夹</h4><p><img src="https://img-blog.csdnimg.cn/20200805200209266.png" alt="在这里插入图片描述"></p><h4 id="里面配置celery"><a href="#里面配置celery" class="headerlink" title="里面配置celery"></a>里面配置celery</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">&#x27;tasks&#x27;</span>, broker=<span class="string">&#x27;redis://localhost&#x27;</span>, backend=<span class="string">&#x27;redis://localhost&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(name=&#x27;myapp.tasks.mail&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span>(<span class="params">mailaddr</span>):</span></span><br><span class="line">    print(mailaddr)</span><br></pre></td></tr></table></figure><h3 id="怎么样是不是超简单"><a href="#怎么样是不是超简单" class="headerlink" title="怎么样是不是超简单"></a>怎么样是不是超简单</h3><h2 id="别急还没完-需要启动celery"><a href="#别急还没完-需要启动celery" class="headerlink" title="别急还没完  需要启动celery"></a>别急还没完  需要启动celery</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery -A tasks worker --pool=solo -l info</span><br></pre></td></tr></table></figure><h1 id="到这里就结束了"><a href="#到这里就结束了" class="headerlink" title="到这里就结束了"></a>到这里就结束了</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先说明我用的django框架,那么为什么要使用celery框架,django3.0以下版本都是同步处理请求,假设我现在有一万个任务,我的django框架是承受不了的,所以就用到了clery异步.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>wrap_socket() got an unexpected keyword argument ‘_context‘</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2017/10/21/wrap_socket()%20got%20an%20unexpected%20keyword%20argument%20%E2%80%98_context%E2%80%98/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2017/10/21/wrap_socket()%20got%20an%20unexpected%20keyword%20argument%20%E2%80%98_context%E2%80%98/</id>
    <published>2017-10-21T04:13:04.000Z</published>
    <updated>2020-09-03T10:58:51.583Z</updated>
    
    <content type="html"><![CDATA[<p>python3.8使用celery报错wrap_socket() got an unexpected keyword argument ‘_context’<br>原启动方法为:<br>起执行任务的服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elery worker -A celery_task -l info -P eventlet</span><br></pre></td></tr></table></figure><p>起提交任务的服务</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery beat -A celery_task -l info</span><br></pre></td></tr></table></figure><p>改变服务器启动方法不要用eventlet，加个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A celery_task --loglevel=info --pool=solo</span><br></pre></td></tr></table></figure><p>注意:celery_task是文件名,注意修改</p><p><strong>解决一切疑难杂症,值得一试</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;python3.8使用celery报错wrap_socket() got an unexpected keyword argument ‘_context’&lt;br&gt;原启动方法为:&lt;br&gt;起执行任务的服务&lt;/p&gt;
&lt;figure class=&quot;highlight python</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>orm最全宝典</title>
    <link href="https://github.com/xuMr6/xumr6.github.io.git/2017/10/16/orm%E6%9C%80%E5%85%A8%E5%AE%9D%E5%85%B8/"/>
    <id>https://github.com/xuMr6/xumr6.github.io.git/2017/10/16/orm%E6%9C%80%E5%85%A8%E5%AE%9D%E5%85%B8/</id>
    <published>2017-10-16T11:56:25.000Z</published>
    <updated>2020-09-03T12:59:55.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本查询"><a href="#一、基本查询" class="headerlink" title="一、基本查询"></a>一、基本查询</h2><ul><li>1.查询编号为1的图书【两种方式】<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects.filter(id=<span class="number">1</span>)  <span class="comment"># 得到的是查询集</span></span><br><span class="line">BookInfo.objects.get(id=<span class="number">1</span>)  <span class="comment"># 有且只有一个id=1的数据,才能正确</span></span><br></pre></td></tr></table></figure></li><li>2.查询所有图书的数量<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects.filter().count()</span><br></pre></td></tr></table></figure></li><li>3.查询书名包含雪山的图书【开头，结尾】<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects.filter(btitle__startswith=<span class="string">&#x27;雪山&#x27;</span>)</span><br><span class="line">BookInfo.objects.filter(btitle__endswith=<span class="string">&#x27;雪山&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li>4.查询书籍名不为空的书籍<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">book = BookInfo.objects.get(id=<span class="number">6</span>)</span><br><span class="line">book.btitle = <span class="literal">None</span></span><br><span class="line">book.save()</span><br><span class="line">book = BookInfo.objects.filter(img__isnull=<span class="literal">False</span>)</span><br><span class="line">print(book)</span><br></pre></td></tr></table></figure></li><li>5.查询书籍编号为1，3，5的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(id__in=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">books = BookInfo.objects.filter(id__range=[<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>6.查询编号大于3的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(id__gt=<span class="number">3</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>7.查询编号大于等于3的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(id__gte=<span class="number">3</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>8.查询编号不等于3的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.exclude(id=<span class="number">3</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>9.查询1980年发表的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(bpub_date__year=<span class="string">&#x27;1980&#x27;</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>10.查询1980年1月1号之后发表的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(bpub_date__gt=<span class="string">&#x27;1990-01-01&#x27;</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、关联过滤查询"><a href="#二、关联过滤查询" class="headerlink" title="二、关联过滤查询"></a>二、关联过滤查询</h2><p> 根据关联的模型的属性过滤</p><ul><li>19.查询书籍编号为1，中的所有英雄<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">heros = HeroInfo.objects.filter(hbook_id=<span class="number">1</span>)</span><br><span class="line">print(heros)</span><br><span class="line">book = BookInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">heros = HeroInfo.objects.filter(hbook=book)</span><br><span class="line">print(heros)</span><br><span class="line">- <span class="number">20.</span>查询书籍名称为雪山飞狐的，所有的英雄</span><br><span class="line">heros = HeroInfo.objects.filter(hbook__btitle=<span class="string">&#x27;雪山飞狐&#x27;</span>)</span><br><span class="line">print(heros)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>21.查询英雄编号为1，所属的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book = HeroInfo.objects.get(id=<span class="number">1</span>).hbook</span><br><span class="line">print(book.btitle)</span><br></pre></td></tr></table></figure></li><li>22.查询英雄中有乔峰的书籍<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(heroinfo__hname=<span class="string">&#x27;乔峰&#x27;</span>)</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>23.查询英雄名字中包含‘郭’的书籍<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(heroinfo__hname__contains=<span class="string">&#x27;不&#x27;</span>).distinct()</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>24.查询书籍阅读量大于30的书籍中的所有英雄<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heros = HeroInfo.objects.filter(hbook__bread__gt=<span class="number">30</span>)</span><br><span class="line">print(heros)</span><br></pre></td></tr></table></figure></li><li>25.取1号图书中的所有英雄<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book = BookInfo.objects.get(id=<span class="number">1</span>)</span><br><span class="line">print(book.heros.all())</span><br></pre></td></tr></table></figure><h2 id="三、FQ查询"><a href="#三、FQ查询" class="headerlink" title="三、FQ查询"></a>三、FQ查询</h2></li><li>11.查询阅读量大于等于评论量的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.all()</span><br><span class="line">book_list = []</span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="keyword">if</span> book.bread&gt;=book.bcomment:</span><br><span class="line">        book_list.append(book)</span><br><span class="line">BookInfo.objects.filter(bread__gte=F(<span class="string">&#x27;bcomment&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li>12.查询阅读量大于等于2倍评论量的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects.filter(bread__gte=F(<span class="string">&#x27;bcomment&#x27;</span>)*<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li>13.查询阅读量大于20，并且编号小于3的图书<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BookInfo.objects.filter(bread__gt=<span class="number">20</span>, id__lt=<span class="number">3</span>)</span><br><span class="line">BookInfo.objects.filter(bread__gt=<span class="number">20</span>).filter(id__lt=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>14.查询阅读量大于20，或编号小于3的图书,  &amp;  |  ~<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(Q(bread__gt=<span class="number">20</span>) | Q(id__lt=<span class="number">3</span>))</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li><li>15.查询编号不等于3的图书，使用Q对象实现<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">books = BookInfo.objects.filter(~Q(id=<span class="number">3</span>))</span><br><span class="line">print(books)</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、聚合查询"><a href="#四、聚合查询" class="headerlink" title="四、聚合查询"></a>四、聚合查询</h2><ul><li><p>16.查询所有阅读量的总和</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bread_sum = BookInfo.objects.all().aggregate(Sum(<span class="string">&#x27;bread&#x27;</span>))</span><br><span class="line">print(bread_sum.get(<span class="string">&#x27;bread__sum&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>17.查询最大的评论量</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 平均数</span></span><br><span class="line">bread_avg = BookInfo.objects.all().aggregate(Avg(<span class="string">&#x27;bread&#x27;</span>))</span><br><span class="line">print(bread_avg)</span><br><span class="line"><span class="comment"># 最小数</span></span><br><span class="line">bread_min = BookInfo.objects.all().aggregate(Min(<span class="string">&#x27;bread&#x27;</span>))</span><br><span class="line">print(bread_min)</span><br><span class="line"><span class="comment"># 最大数</span></span><br><span class="line">bread_max = BookInfo.objects.all().aggregate(Max(<span class="string">&#x27;bread&#x27;</span>))</span><br><span class="line">print(bread_max)</span><br></pre></td></tr></table></figure></li><li><p>18.查询所有图书，按照阅读量排序，升序【降序】</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(BookInfo.objects.all().order_by(<span class="string">&#x27;bread&#x27;</span>)[:<span class="number">3</span>])</span><br><span class="line">print(BookInfo.objects.all().order_by(<span class="string">&#x27;-bread&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>复杂的查询语句<br>books = BookInfo.objects.filter(Q(id__gt=3) | Q(bread__gte=20)).order_by(‘bcomment’)[:3]<br>print(books.query)</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、基本查询&quot;&gt;&lt;a href=&quot;#一、基本查询&quot; class=&quot;headerlink&quot; title=&quot;一、基本查询&quot;&gt;&lt;/a&gt;一、基本查询&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.查询编号为1的图书【两种方式】&lt;figure class=&quot;highlight py&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="python" scheme="https://github.com/xuMr6/xumr6.github.io.git/tags/python/"/>
    
  </entry>
  
</feed>
